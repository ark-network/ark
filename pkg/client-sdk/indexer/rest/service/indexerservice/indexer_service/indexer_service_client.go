// Code generated by go-swagger; DO NOT EDIT.

package indexer_service

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new indexer service API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new indexer service API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new indexer service API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for indexer service API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	IndexerServiceGetCommitmentTx(params *IndexerServiceGetCommitmentTxParams, opts ...ClientOption) (*IndexerServiceGetCommitmentTxOK, error)

	IndexerServiceGetCommitmentTxLeaves(params *IndexerServiceGetCommitmentTxLeavesParams, opts ...ClientOption) (*IndexerServiceGetCommitmentTxLeavesOK, error)

	IndexerServiceGetConnectors(params *IndexerServiceGetConnectorsParams, opts ...ClientOption) (*IndexerServiceGetConnectorsOK, error)

	IndexerServiceGetForfeitTxs(params *IndexerServiceGetForfeitTxsParams, opts ...ClientOption) (*IndexerServiceGetForfeitTxsOK, error)

	IndexerServiceGetSubscription(params *IndexerServiceGetSubscriptionParams, opts ...ClientOption) (*IndexerServiceGetSubscriptionOK, error)

	IndexerServiceGetSweptCommitmentTx(params *IndexerServiceGetSweptCommitmentTxParams, opts ...ClientOption) (*IndexerServiceGetSweptCommitmentTxOK, error)

	IndexerServiceGetTransactionHistory(params *IndexerServiceGetTransactionHistoryParams, opts ...ClientOption) (*IndexerServiceGetTransactionHistoryOK, error)

	IndexerServiceGetVirtualTxs(params *IndexerServiceGetVirtualTxsParams, opts ...ClientOption) (*IndexerServiceGetVirtualTxsOK, error)

	IndexerServiceGetVtxoChain(params *IndexerServiceGetVtxoChainParams, opts ...ClientOption) (*IndexerServiceGetVtxoChainOK, error)

	IndexerServiceGetVtxoTree(params *IndexerServiceGetVtxoTreeParams, opts ...ClientOption) (*IndexerServiceGetVtxoTreeOK, error)

	IndexerServiceGetVtxoTreeLeaves(params *IndexerServiceGetVtxoTreeLeavesParams, opts ...ClientOption) (*IndexerServiceGetVtxoTreeLeavesOK, error)

	IndexerServiceGetVtxos(params *IndexerServiceGetVtxosParams, opts ...ClientOption) (*IndexerServiceGetVtxosOK, error)

	IndexerServiceSubscribeForScripts(params *IndexerServiceSubscribeForScriptsParams, opts ...ClientOption) (*IndexerServiceSubscribeForScriptsOK, error)

	IndexerServiceUnsubscribeForScripts(params *IndexerServiceUnsubscribeForScriptsParams, opts ...ClientOption) (*IndexerServiceUnsubscribeForScriptsOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
IndexerServiceGetCommitmentTx gets commitment tx returns information about a specific commitment transaction identified by the provided txid
*/
func (a *Client) IndexerServiceGetCommitmentTx(params *IndexerServiceGetCommitmentTxParams, opts ...ClientOption) (*IndexerServiceGetCommitmentTxOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetCommitmentTxParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetCommitmentTx",
		Method:             "GET",
		PathPattern:        "/v1/commitmentTx/{txid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetCommitmentTxReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetCommitmentTxOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetCommitmentTxDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceGetCommitmentTxLeaves gets commitment tx leaves returns the list of leaves vtxo outpoints of all batch outputs trees included in the provided commitment transaction the response may include pagination information if the results span multiple pages
*/
func (a *Client) IndexerServiceGetCommitmentTxLeaves(params *IndexerServiceGetCommitmentTxLeavesParams, opts ...ClientOption) (*IndexerServiceGetCommitmentTxLeavesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetCommitmentTxLeavesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetCommitmentTxLeaves",
		Method:             "GET",
		PathPattern:        "/v1/commitmentTx/{txid}/leaves",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetCommitmentTxLeavesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetCommitmentTxLeavesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetCommitmentTxLeavesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceGetConnectors gets connectors returns the tree of connectors for the provided commitment transaction the response includes a list of connector txs with details on the tree posistion and may include pagination information if the results span multiple pages
*/
func (a *Client) IndexerServiceGetConnectors(params *IndexerServiceGetConnectorsParams, opts ...ClientOption) (*IndexerServiceGetConnectorsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetConnectorsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetConnectors",
		Method:             "GET",
		PathPattern:        "/v1/commitmentTx/{txid}/connectors",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetConnectorsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetConnectorsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetConnectorsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceGetForfeitTxs gets forfeit txs returns the list of forfeit transactions that were submitted for the provided commitment transaction the response may include pagination information if the results span multiple pages
*/
func (a *Client) IndexerServiceGetForfeitTxs(params *IndexerServiceGetForfeitTxsParams, opts ...ClientOption) (*IndexerServiceGetForfeitTxsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetForfeitTxsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetForfeitTxs",
		Method:             "GET",
		PathPattern:        "/v1/commitmentTx/{txid}/forfeitTxs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetForfeitTxsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetForfeitTxsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetForfeitTxsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceGetSubscription gets subscription is a server side streaming RPC which allows clients to receive real time notifications on transactions related to the subscribed vtxo scripts the subscription can be created or updated by using the subscribe for scripts and unsubscribe for scripts r p cs
*/
func (a *Client) IndexerServiceGetSubscription(params *IndexerServiceGetSubscriptionParams, opts ...ClientOption) (*IndexerServiceGetSubscriptionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetSubscriptionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetSubscription",
		Method:             "GET",
		PathPattern:        "/v1/script/subscription/{subscriptionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetSubscriptionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetSubscriptionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetSubscriptionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceGetSweptCommitmentTx gets swept commitment tx returns the list of transaction txid that swept each batch output of the specified commitment transaction in most cases the list contains only one txid per batch that means the funds locked in the batch output have been claimed back if any of the leaves of the tree vtxo have been unrolled onchain before the expiration the list will contain many txids in a binary tree with 4 or more leaves 1 unroll causes the server to broadcast 3 txs to sweep the whole tree for example if a whole vtxo tree has been unrolled onchain the list of txids for that batch output is be empty
*/
func (a *Client) IndexerServiceGetSweptCommitmentTx(params *IndexerServiceGetSweptCommitmentTxParams, opts ...ClientOption) (*IndexerServiceGetSweptCommitmentTxOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetSweptCommitmentTxParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetSweptCommitmentTx",
		Method:             "GET",
		PathPattern:        "/v1/commitmentTx/{txid}/swept",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetSweptCommitmentTxReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetSweptCommitmentTxOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetSweptCommitmentTxDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceGetTransactionHistory gets transaction history returns the list of transactions for the provided address the tx history can be filtered by defining a start and or end time the response may be paginated if the results span multiple pages
*/
func (a *Client) IndexerServiceGetTransactionHistory(params *IndexerServiceGetTransactionHistoryParams, opts ...ClientOption) (*IndexerServiceGetTransactionHistoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetTransactionHistoryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetTransactionHistory",
		Method:             "GET",
		PathPattern:        "/v1/history/{address}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetTransactionHistoryReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetTransactionHistoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetTransactionHistoryDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceGetVirtualTxs gets virtual txs returns the virtual transactions in hex format for the specified txids the response may be paginated if the results span multiple pages
*/
func (a *Client) IndexerServiceGetVirtualTxs(params *IndexerServiceGetVirtualTxsParams, opts ...ClientOption) (*IndexerServiceGetVirtualTxsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetVirtualTxsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetVirtualTxs",
		Method:             "GET",
		PathPattern:        "/v1/virtualTx/{txids}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetVirtualTxsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetVirtualTxsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetVirtualTxsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceGetVtxoChain gets vtxo chain returns the the chain of ark txs that starts from spending any vtxo leaf and ends with the creation of the provided vtxo outpoint the response may be paginated if the results span multiple pages
*/
func (a *Client) IndexerServiceGetVtxoChain(params *IndexerServiceGetVtxoChainParams, opts ...ClientOption) (*IndexerServiceGetVtxoChainOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetVtxoChainParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetVtxoChain",
		Method:             "GET",
		PathPattern:        "/v1/vtxo/{outpoint.txid}/{outpoint.vout}/chain",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetVtxoChainReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetVtxoChainOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetVtxoChainDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceGetVtxoTree gets vtxo tree returns the vtxo tree for the provided batch outpoint the response includes a list of txs with details on the tree posistion and may include pagination information if the results span multiple pages
*/
func (a *Client) IndexerServiceGetVtxoTree(params *IndexerServiceGetVtxoTreeParams, opts ...ClientOption) (*IndexerServiceGetVtxoTreeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetVtxoTreeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetVtxoTree",
		Method:             "GET",
		PathPattern:        "/v1/batch/{batchOutpoint.txid}/{batchOutpoint.vout}/tree",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetVtxoTreeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetVtxoTreeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetVtxoTreeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceGetVtxoTreeLeaves gets vtxo tree leaves returns the list of leaves vtxo outpoints of the tree s for the provided batch outpoint the response may be paginated if the results span multiple pages
*/
func (a *Client) IndexerServiceGetVtxoTreeLeaves(params *IndexerServiceGetVtxoTreeLeavesParams, opts ...ClientOption) (*IndexerServiceGetVtxoTreeLeavesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetVtxoTreeLeavesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetVtxoTreeLeaves",
		Method:             "GET",
		PathPattern:        "/v1/batch/{batchOutpoint.txid}/{batchOutpoint.vout}/tree/leaves",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetVtxoTreeLeavesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetVtxoTreeLeavesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetVtxoTreeLeavesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceGetVtxos gets vtxos returns the list of vtxos based on the provided filter vtxos can be retrieved either by addresses or by outpoints and optionally filtered by spendable or spent only the response may be paginated if the results span multiple pages
*/
func (a *Client) IndexerServiceGetVtxos(params *IndexerServiceGetVtxosParams, opts ...ClientOption) (*IndexerServiceGetVtxosOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceGetVtxosParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_GetVtxos",
		Method:             "GET",
		PathPattern:        "/v1/vtxos",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceGetVtxosReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceGetVtxosOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceGetVtxosDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceSubscribeForScripts subscribes for scripts allows to subscribe for tx notifications related to the provided vtxo scripts it can also be used to update an existing subscribtion by adding new scripts to it
*/
func (a *Client) IndexerServiceSubscribeForScripts(params *IndexerServiceSubscribeForScriptsParams, opts ...ClientOption) (*IndexerServiceSubscribeForScriptsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceSubscribeForScriptsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_SubscribeForScripts",
		Method:             "POST",
		PathPattern:        "/v1/script/subscribe",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceSubscribeForScriptsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceSubscribeForScriptsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceSubscribeForScriptsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IndexerServiceUnsubscribeForScripts unsubscribes for scripts allows to remove scripts from an existing subscription
*/
func (a *Client) IndexerServiceUnsubscribeForScripts(params *IndexerServiceUnsubscribeForScriptsParams, opts ...ClientOption) (*IndexerServiceUnsubscribeForScriptsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIndexerServiceUnsubscribeForScriptsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "IndexerService_UnsubscribeForScripts",
		Method:             "POST",
		PathPattern:        "/v1/script/unsubscribe",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &IndexerServiceUnsubscribeForScriptsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IndexerServiceUnsubscribeForScriptsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IndexerServiceUnsubscribeForScriptsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
