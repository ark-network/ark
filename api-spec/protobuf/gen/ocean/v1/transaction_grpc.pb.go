// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package oceanv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TransactionServiceClient is the client API for TransactionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TransactionServiceClient interface {
	// GetTransaction returns the hex of a transaction given its id.
	GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
	// SelectUtxos returns a selction of utxos, to be used in another
	// transaction, for provided target amount and strategy.
	// Selected utxos are locked for predefined amount of time to prevent
	// double-spending them.
	SelectUtxos(ctx context.Context, in *SelectUtxosRequest, opts ...grpc.CallOption) (*SelectUtxosResponse, error)
	// LockUtxos allows to manually select utxos to spend by a subsequent tx.
	LockUtxos(ctx context.Context, in *LockUtxosRequest, opts ...grpc.CallOption) (*LockUtxosResponse, error)
	// EstimateFees returns the fee amount to pay for a tx containing the given
	// inputs and outputs.
	EstimateFees(ctx context.Context, in *EstimateFeesRequest, opts ...grpc.CallOption) (*EstimateFeesResponse, error)
	// SignTransaction signs a raw transaction in hex format.
	SignTransaction(ctx context.Context, in *SignTransactionRequest, opts ...grpc.CallOption) (*SignTransactionResponse, error)
	// BroadcastTransaction broadacats a raw transaction in hex format.
	BroadcastTransaction(ctx context.Context, in *BroadcastTransactionRequest, opts ...grpc.CallOption) (*BroadcastTransactionResponse, error)
	// CreatePset returns an unsigned pset for given inputs and outputs.
	CreatePset(ctx context.Context, in *CreatePsetRequest, opts ...grpc.CallOption) (*CreatePsetResponse, error)
	// UpdatePset adds the given inputs and outputs to the partial transaction.
	UpdatePset(ctx context.Context, in *UpdatePsetRequest, opts ...grpc.CallOption) (*UpdatePsetResponse, error)
	// BlindPset updates the given pset with required ins and outs blinded.
	BlindPset(ctx context.Context, in *BlindPsetRequest, opts ...grpc.CallOption) (*BlindPsetResponse, error)
	// SignPset updates the given pset adding the required signatures.
	SignPset(ctx context.Context, in *SignPsetRequest, opts ...grpc.CallOption) (*SignPsetResponse, error)
	// Mint returns a transaction that issues a new asset.
	Mint(ctx context.Context, in *MintRequest, opts ...grpc.CallOption) (*MintResponse, error)
	// Remint returns a transaction that re-issues an existing asset.
	Remint(ctx context.Context, in *RemintRequest, opts ...grpc.CallOption) (*RemintResponse, error)
	// Burn returns a transaction that burns some funds.
	Burn(ctx context.Context, in *BurnRequest, opts ...grpc.CallOption) (*BurnResponse, error)
	// Transfer returns a transaction to send funds to some receiver.
	Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error)
	// PegInAddress returns what's necessary to peg funds of the Bitcoin
	// main-chain and have them available on the Liquid side-chain.
	// Bitcoin funds must be sent to the main-chain address while the claim
	// output script must be used to redeem the LBTC ones.
	PegInAddress(ctx context.Context, in *PegInAddressRequest, opts ...grpc.CallOption) (*PegInAddressResponse, error)
	// ClaimPegIn returns a transaction to claim funds pegged on the Bitcoin
	// main-chain to have them available on the Liquid side-chain.
	ClaimPegIn(ctx context.Context, in *ClaimPegInRequest, opts ...grpc.CallOption) (*ClaimPegInResponse, error)
	// SignPsetWithSchnorrKey signs all taproot inputs of the provided tx with
	// the key at the given derivation path.
	SignPsetWithSchnorrKey(ctx context.Context, in *SignPsetWithSchnorrKeyRequest, opts ...grpc.CallOption) (*SignPsetWithSchnorrKeyResponse, error)
}

type transactionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTransactionServiceClient(cc grpc.ClientConnInterface) TransactionServiceClient {
	return &transactionServiceClient{cc}
}

func (c *transactionServiceClient) GetTransaction(ctx context.Context, in *GetTransactionRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) {
	out := new(GetTransactionResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/GetTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) SelectUtxos(ctx context.Context, in *SelectUtxosRequest, opts ...grpc.CallOption) (*SelectUtxosResponse, error) {
	out := new(SelectUtxosResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/SelectUtxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) LockUtxos(ctx context.Context, in *LockUtxosRequest, opts ...grpc.CallOption) (*LockUtxosResponse, error) {
	out := new(LockUtxosResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/LockUtxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) EstimateFees(ctx context.Context, in *EstimateFeesRequest, opts ...grpc.CallOption) (*EstimateFeesResponse, error) {
	out := new(EstimateFeesResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/EstimateFees", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) SignTransaction(ctx context.Context, in *SignTransactionRequest, opts ...grpc.CallOption) (*SignTransactionResponse, error) {
	out := new(SignTransactionResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/SignTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) BroadcastTransaction(ctx context.Context, in *BroadcastTransactionRequest, opts ...grpc.CallOption) (*BroadcastTransactionResponse, error) {
	out := new(BroadcastTransactionResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/BroadcastTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) CreatePset(ctx context.Context, in *CreatePsetRequest, opts ...grpc.CallOption) (*CreatePsetResponse, error) {
	out := new(CreatePsetResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/CreatePset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) UpdatePset(ctx context.Context, in *UpdatePsetRequest, opts ...grpc.CallOption) (*UpdatePsetResponse, error) {
	out := new(UpdatePsetResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/UpdatePset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) BlindPset(ctx context.Context, in *BlindPsetRequest, opts ...grpc.CallOption) (*BlindPsetResponse, error) {
	out := new(BlindPsetResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/BlindPset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) SignPset(ctx context.Context, in *SignPsetRequest, opts ...grpc.CallOption) (*SignPsetResponse, error) {
	out := new(SignPsetResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/SignPset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) Mint(ctx context.Context, in *MintRequest, opts ...grpc.CallOption) (*MintResponse, error) {
	out := new(MintResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/Mint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) Remint(ctx context.Context, in *RemintRequest, opts ...grpc.CallOption) (*RemintResponse, error) {
	out := new(RemintResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/Remint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) Burn(ctx context.Context, in *BurnRequest, opts ...grpc.CallOption) (*BurnResponse, error) {
	out := new(BurnResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/Burn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error) {
	out := new(TransferResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/Transfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) PegInAddress(ctx context.Context, in *PegInAddressRequest, opts ...grpc.CallOption) (*PegInAddressResponse, error) {
	out := new(PegInAddressResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/PegInAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) ClaimPegIn(ctx context.Context, in *ClaimPegInRequest, opts ...grpc.CallOption) (*ClaimPegInResponse, error) {
	out := new(ClaimPegInResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/ClaimPegIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionServiceClient) SignPsetWithSchnorrKey(ctx context.Context, in *SignPsetWithSchnorrKeyRequest, opts ...grpc.CallOption) (*SignPsetWithSchnorrKeyResponse, error) {
	out := new(SignPsetWithSchnorrKeyResponse)
	err := c.cc.Invoke(ctx, "/ocean.v1.TransactionService/SignPsetWithSchnorrKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TransactionServiceServer is the server API for TransactionService service.
// All implementations should embed UnimplementedTransactionServiceServer
// for forward compatibility
type TransactionServiceServer interface {
	// GetTransaction returns the hex of a transaction given its id.
	GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error)
	// SelectUtxos returns a selction of utxos, to be used in another
	// transaction, for provided target amount and strategy.
	// Selected utxos are locked for predefined amount of time to prevent
	// double-spending them.
	SelectUtxos(context.Context, *SelectUtxosRequest) (*SelectUtxosResponse, error)
	// LockUtxos allows to manually select utxos to spend by a subsequent tx.
	LockUtxos(context.Context, *LockUtxosRequest) (*LockUtxosResponse, error)
	// EstimateFees returns the fee amount to pay for a tx containing the given
	// inputs and outputs.
	EstimateFees(context.Context, *EstimateFeesRequest) (*EstimateFeesResponse, error)
	// SignTransaction signs a raw transaction in hex format.
	SignTransaction(context.Context, *SignTransactionRequest) (*SignTransactionResponse, error)
	// BroadcastTransaction broadacats a raw transaction in hex format.
	BroadcastTransaction(context.Context, *BroadcastTransactionRequest) (*BroadcastTransactionResponse, error)
	// CreatePset returns an unsigned pset for given inputs and outputs.
	CreatePset(context.Context, *CreatePsetRequest) (*CreatePsetResponse, error)
	// UpdatePset adds the given inputs and outputs to the partial transaction.
	UpdatePset(context.Context, *UpdatePsetRequest) (*UpdatePsetResponse, error)
	// BlindPset updates the given pset with required ins and outs blinded.
	BlindPset(context.Context, *BlindPsetRequest) (*BlindPsetResponse, error)
	// SignPset updates the given pset adding the required signatures.
	SignPset(context.Context, *SignPsetRequest) (*SignPsetResponse, error)
	// Mint returns a transaction that issues a new asset.
	Mint(context.Context, *MintRequest) (*MintResponse, error)
	// Remint returns a transaction that re-issues an existing asset.
	Remint(context.Context, *RemintRequest) (*RemintResponse, error)
	// Burn returns a transaction that burns some funds.
	Burn(context.Context, *BurnRequest) (*BurnResponse, error)
	// Transfer returns a transaction to send funds to some receiver.
	Transfer(context.Context, *TransferRequest) (*TransferResponse, error)
	// PegInAddress returns what's necessary to peg funds of the Bitcoin
	// main-chain and have them available on the Liquid side-chain.
	// Bitcoin funds must be sent to the main-chain address while the claim
	// output script must be used to redeem the LBTC ones.
	PegInAddress(context.Context, *PegInAddressRequest) (*PegInAddressResponse, error)
	// ClaimPegIn returns a transaction to claim funds pegged on the Bitcoin
	// main-chain to have them available on the Liquid side-chain.
	ClaimPegIn(context.Context, *ClaimPegInRequest) (*ClaimPegInResponse, error)
	// SignPsetWithSchnorrKey signs all taproot inputs of the provided tx with
	// the key at the given derivation path.
	SignPsetWithSchnorrKey(context.Context, *SignPsetWithSchnorrKeyRequest) (*SignPsetWithSchnorrKeyResponse, error)
}

// UnimplementedTransactionServiceServer should be embedded to have forward compatible implementations.
type UnimplementedTransactionServiceServer struct {
}

func (UnimplementedTransactionServiceServer) GetTransaction(context.Context, *GetTransactionRequest) (*GetTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransaction not implemented")
}
func (UnimplementedTransactionServiceServer) SelectUtxos(context.Context, *SelectUtxosRequest) (*SelectUtxosResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SelectUtxos not implemented")
}
func (UnimplementedTransactionServiceServer) LockUtxos(context.Context, *LockUtxosRequest) (*LockUtxosResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockUtxos not implemented")
}
func (UnimplementedTransactionServiceServer) EstimateFees(context.Context, *EstimateFeesRequest) (*EstimateFeesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateFees not implemented")
}
func (UnimplementedTransactionServiceServer) SignTransaction(context.Context, *SignTransactionRequest) (*SignTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignTransaction not implemented")
}
func (UnimplementedTransactionServiceServer) BroadcastTransaction(context.Context, *BroadcastTransactionRequest) (*BroadcastTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastTransaction not implemented")
}
func (UnimplementedTransactionServiceServer) CreatePset(context.Context, *CreatePsetRequest) (*CreatePsetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePset not implemented")
}
func (UnimplementedTransactionServiceServer) UpdatePset(context.Context, *UpdatePsetRequest) (*UpdatePsetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePset not implemented")
}
func (UnimplementedTransactionServiceServer) BlindPset(context.Context, *BlindPsetRequest) (*BlindPsetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlindPset not implemented")
}
func (UnimplementedTransactionServiceServer) SignPset(context.Context, *SignPsetRequest) (*SignPsetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignPset not implemented")
}
func (UnimplementedTransactionServiceServer) Mint(context.Context, *MintRequest) (*MintResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mint not implemented")
}
func (UnimplementedTransactionServiceServer) Remint(context.Context, *RemintRequest) (*RemintResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remint not implemented")
}
func (UnimplementedTransactionServiceServer) Burn(context.Context, *BurnRequest) (*BurnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Burn not implemented")
}
func (UnimplementedTransactionServiceServer) Transfer(context.Context, *TransferRequest) (*TransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transfer not implemented")
}
func (UnimplementedTransactionServiceServer) PegInAddress(context.Context, *PegInAddressRequest) (*PegInAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PegInAddress not implemented")
}
func (UnimplementedTransactionServiceServer) ClaimPegIn(context.Context, *ClaimPegInRequest) (*ClaimPegInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimPegIn not implemented")
}
func (UnimplementedTransactionServiceServer) SignPsetWithSchnorrKey(context.Context, *SignPsetWithSchnorrKeyRequest) (*SignPsetWithSchnorrKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignPsetWithSchnorrKey not implemented")
}

// UnsafeTransactionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TransactionServiceServer will
// result in compilation errors.
type UnsafeTransactionServiceServer interface {
	mustEmbedUnimplementedTransactionServiceServer()
}

func RegisterTransactionServiceServer(s grpc.ServiceRegistrar, srv TransactionServiceServer) {
	s.RegisterService(&TransactionService_ServiceDesc, srv)
}

func _TransactionService_GetTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).GetTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/GetTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).GetTransaction(ctx, req.(*GetTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_SelectUtxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelectUtxosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).SelectUtxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/SelectUtxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).SelectUtxos(ctx, req.(*SelectUtxosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_LockUtxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockUtxosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).LockUtxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/LockUtxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).LockUtxos(ctx, req.(*LockUtxosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_EstimateFees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateFeesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).EstimateFees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/EstimateFees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).EstimateFees(ctx, req.(*EstimateFeesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_SignTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).SignTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/SignTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).SignTransaction(ctx, req.(*SignTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_BroadcastTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).BroadcastTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/BroadcastTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).BroadcastTransaction(ctx, req.(*BroadcastTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_CreatePset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).CreatePset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/CreatePset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).CreatePset(ctx, req.(*CreatePsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_UpdatePset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).UpdatePset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/UpdatePset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).UpdatePset(ctx, req.(*UpdatePsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_BlindPset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlindPsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).BlindPset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/BlindPset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).BlindPset(ctx, req.(*BlindPsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_SignPset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignPsetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).SignPset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/SignPset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).SignPset(ctx, req.(*SignPsetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_Mint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MintRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).Mint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/Mint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).Mint(ctx, req.(*MintRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_Remint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemintRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).Remint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/Remint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).Remint(ctx, req.(*RemintRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_Burn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BurnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).Burn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/Burn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).Burn(ctx, req.(*BurnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_Transfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).Transfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/Transfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).Transfer(ctx, req.(*TransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_PegInAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PegInAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).PegInAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/PegInAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).PegInAddress(ctx, req.(*PegInAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_ClaimPegIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimPegInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).ClaimPegIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/ClaimPegIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).ClaimPegIn(ctx, req.(*ClaimPegInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionService_SignPsetWithSchnorrKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignPsetWithSchnorrKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionServiceServer).SignPsetWithSchnorrKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ocean.v1.TransactionService/SignPsetWithSchnorrKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionServiceServer).SignPsetWithSchnorrKey(ctx, req.(*SignPsetWithSchnorrKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TransactionService_ServiceDesc is the grpc.ServiceDesc for TransactionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TransactionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ocean.v1.TransactionService",
	HandlerType: (*TransactionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTransaction",
			Handler:    _TransactionService_GetTransaction_Handler,
		},
		{
			MethodName: "SelectUtxos",
			Handler:    _TransactionService_SelectUtxos_Handler,
		},
		{
			MethodName: "LockUtxos",
			Handler:    _TransactionService_LockUtxos_Handler,
		},
		{
			MethodName: "EstimateFees",
			Handler:    _TransactionService_EstimateFees_Handler,
		},
		{
			MethodName: "SignTransaction",
			Handler:    _TransactionService_SignTransaction_Handler,
		},
		{
			MethodName: "BroadcastTransaction",
			Handler:    _TransactionService_BroadcastTransaction_Handler,
		},
		{
			MethodName: "CreatePset",
			Handler:    _TransactionService_CreatePset_Handler,
		},
		{
			MethodName: "UpdatePset",
			Handler:    _TransactionService_UpdatePset_Handler,
		},
		{
			MethodName: "BlindPset",
			Handler:    _TransactionService_BlindPset_Handler,
		},
		{
			MethodName: "SignPset",
			Handler:    _TransactionService_SignPset_Handler,
		},
		{
			MethodName: "Mint",
			Handler:    _TransactionService_Mint_Handler,
		},
		{
			MethodName: "Remint",
			Handler:    _TransactionService_Remint_Handler,
		},
		{
			MethodName: "Burn",
			Handler:    _TransactionService_Burn_Handler,
		},
		{
			MethodName: "Transfer",
			Handler:    _TransactionService_Transfer_Handler,
		},
		{
			MethodName: "PegInAddress",
			Handler:    _TransactionService_PegInAddress_Handler,
		},
		{
			MethodName: "ClaimPegIn",
			Handler:    _TransactionService_ClaimPegIn_Handler,
		},
		{
			MethodName: "SignPsetWithSchnorrKey",
			Handler:    _TransactionService_SignPsetWithSchnorrKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ocean/v1/transaction.proto",
}
