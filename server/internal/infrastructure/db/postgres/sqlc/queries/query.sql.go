// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const getExistingRounds = `-- name: GetExistingRounds :many
SELECT id, starting_timestamp, ending_timestamp, ended, failed, stage_code, connector_address, version, swept, vtxo_tree_expiration, txid, tx, round_id, type, position, children FROM round_commitment_tx_vw r
WHERE r.txid = ANY($1::varchar[])
`

func (q *Queries) GetExistingRounds(ctx context.Context, dollar_1 []string) ([]RoundCommitmentTxVw, error) {
	rows, err := q.db.QueryContext(ctx, getExistingRounds, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoundCommitmentTxVw
	for rows.Next() {
		var i RoundCommitmentTxVw
		if err := rows.Scan(
			&i.ID,
			&i.StartingTimestamp,
			&i.EndingTimestamp,
			&i.Ended,
			&i.Failed,
			&i.StageCode,
			&i.ConnectorAddress,
			&i.Version,
			&i.Swept,
			&i.VtxoTreeExpiration,
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMarketHour = `-- name: GetLatestMarketHour :one
SELECT id, start_time, end_time, period, round_interval, updated_at FROM market_hour ORDER BY updated_at DESC LIMIT 1
`

func (q *Queries) GetLatestMarketHour(ctx context.Context) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, getLatestMarketHour)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoundConnectorTreeTxs = `-- name: GetRoundConnectorTreeTxs :many
SELECT t.txid, t.tx, t.round_id, t.type, t.position, t.children FROM tx t
WHERE t.round_id IN (SELECT rctv.round_id FROM round_commitment_tx_vw rctv WHERE rctv.txid = $1)
    AND t.type = 'connector'
`

func (q *Queries) GetRoundConnectorTreeTxs(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, getRoundConnectorTreeTxs, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoundForfeitTxs = `-- name: GetRoundForfeitTxs :many
SELECT t.txid, t.tx, t.round_id, t.type, t.position, t.children FROM tx t
WHERE t.round_id IN (SELECT rctv.round_id FROM round_commitment_tx_vw rctv WHERE rctv.txid = $1)
    AND t.type = 'forfeit'
`

func (q *Queries) GetRoundForfeitTxs(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, getRoundForfeitTxs, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoundStats = `-- name: GetRoundStats :one
SELECT
    r.swept,
    r.starting_timestamp,
    r.ending_timestamp,
    (
        SELECT COALESCE(SUM(amount), 0)
        FROM (
                 SELECT DISTINCT v2.txid, v2.vout, v2.pubkey, v2.amount, v2.commitment_txid, v2.spent_by, v2.spent, v2.redeemed, v2.swept, v2.expire_at, v2.created_at, v2.request_id
                 FROM vtxo v2
                          JOIN tx_request req2 ON req2.id = v2.request_id
                 WHERE req2.round_id = r.id
             ) as tx_req_inputs_amount
    ) AS total_forfeit_amount,
    (
        SELECT COALESCE(COUNT(v3.txid), 0)
        FROM vtxo v3
                 JOIN tx_request req3 ON req3.id = v3.request_id
        WHERE req3.round_id = r.id
    ) AS total_input_vtxos,
    (
        SELECT COALESCE(SUM(amount), 0)
        FROM (
                 SELECT DISTINCT rr.request_id, rr.pubkey, rr.onchain_address, rr.amount
                 FROM receiver rr
                          JOIN tx_request req4 ON req4.id = rr.request_id
                 WHERE req4.round_id = r.id
                   AND (rr.onchain_address = '' OR rr.onchain_address IS NULL)
             ) AS tx_req_outputs_amount
    ) AS total_batch_amount,
    (
        SELECT COUNT(*)
        FROM tx t
        WHERE t.round_id = r.id
          AND t.type = 'tree'
          AND TRIM(COALESCE(t.children, '')) = ''
    ) AS total_output_vtxos,
    (
        SELECT MAX(v.expire_at)
        FROM vtxo v
        WHERE v.commitment_txid = r.txid
    ) AS expires_at
FROM round_commitment_tx_vw r
WHERE r.txid = $1
`

type GetRoundStatsRow struct {
	Swept              bool
	StartingTimestamp  int64
	EndingTimestamp    int64
	TotalForfeitAmount interface{}
	TotalInputVtxos    interface{}
	TotalBatchAmount   interface{}
	TotalOutputVtxos   int64
	ExpiresAt          interface{}
}

func (q *Queries) GetRoundStats(ctx context.Context, txid string) (GetRoundStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getRoundStats, txid)
	var i GetRoundStatsRow
	err := row.Scan(
		&i.Swept,
		&i.StartingTimestamp,
		&i.EndingTimestamp,
		&i.TotalForfeitAmount,
		&i.TotalInputVtxos,
		&i.TotalBatchAmount,
		&i.TotalOutputVtxos,
		&i.ExpiresAt,
	)
	return i, err
}

const getSpendableVtxosWithPubKey = `-- name: GetSpendableVtxosWithPubKey :many
SELECT vtxo_virtual_tx_vw.txid, vtxo_virtual_tx_vw.vout, vtxo_virtual_tx_vw.pubkey, vtxo_virtual_tx_vw.amount, vtxo_virtual_tx_vw.commitment_txid, vtxo_virtual_tx_vw.spent_by, vtxo_virtual_tx_vw.spent, vtxo_virtual_tx_vw.redeemed, vtxo_virtual_tx_vw.swept, vtxo_virtual_tx_vw.expire_at, vtxo_virtual_tx_vw.created_at, vtxo_virtual_tx_vw.request_id, vtxo_virtual_tx_vw.redeem_txFROM vtxo_virtual_tx_vw
WHERE pubkey = $1 AND spent = false AND swept = false
`

type GetSpendableVtxosWithPubKeyRow struct {
	VtxoVirtualTxVw VtxoVirtualTxVw
}

func (q *Queries) GetSpendableVtxosWithPubKey(ctx context.Context, pubkey string) ([]GetSpendableVtxosWithPubKeyRow, error) {
	rows, err := q.db.QueryContext(ctx, getSpendableVtxosWithPubKey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpendableVtxosWithPubKeyRow
	for rows.Next() {
		var i GetSpendableVtxosWithPubKeyRow
		if err := rows.Scan(
			&i.VtxoVirtualTxVw.Txid,
			&i.VtxoVirtualTxVw.Vout,
			&i.VtxoVirtualTxVw.Pubkey,
			&i.VtxoVirtualTxVw.Amount,
			&i.VtxoVirtualTxVw.CommitmentTxid,
			&i.VtxoVirtualTxVw.SpentBy,
			&i.VtxoVirtualTxVw.Spent,
			&i.VtxoVirtualTxVw.Redeemed,
			&i.VtxoVirtualTxVw.Swept,
			&i.VtxoVirtualTxVw.ExpireAt,
			&i.VtxoVirtualTxVw.CreatedAt,
			&i.VtxoVirtualTxVw.RequestID,
			&i.VtxoVirtualTxVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTxsByTxid = `-- name: GetTxsByTxid :many
SELECT
    tx.txid,
    tx.tx AS data
FROM tx
WHERE tx.txid = ANY($1::varchar[])
`

type GetTxsByTxidRow struct {
	Txid string
	Data string
}

func (q *Queries) GetTxsByTxid(ctx context.Context, dollar_1 []string) ([]GetTxsByTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, getTxsByTxid, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTxsByTxidRow
	for rows.Next() {
		var i GetTxsByTxidRow
		if err := rows.Scan(&i.Txid, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMarketHour = `-- name: InsertMarketHour :one
INSERT INTO market_hour (
    start_time,
    end_time,
    period,
    round_interval,
    updated_at
) VALUES ($1, $2, $3, $4, $5)
    RETURNING id, start_time, end_time, period, round_interval, updated_at
`

type InsertMarketHourParams struct {
	StartTime     int64
	EndTime       int64
	Period        int64
	RoundInterval int64
	UpdatedAt     int64
}

func (q *Queries) InsertMarketHour(ctx context.Context, arg InsertMarketHourParams) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, insertMarketHour,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.RoundInterval,
		arg.UpdatedAt,
	)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const markVtxoAsRedeemed = `-- name: MarkVtxoAsRedeemed :exec
UPDATE vtxo SET redeemed = true WHERE txid = $1 AND vout = $2
`

type MarkVtxoAsRedeemedParams struct {
	Txid string
	Vout int32
}

func (q *Queries) MarkVtxoAsRedeemed(ctx context.Context, arg MarkVtxoAsRedeemedParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsRedeemed, arg.Txid, arg.Vout)
	return err
}

const markVtxoAsSpent = `-- name: MarkVtxoAsSpent :exec
UPDATE vtxo SET spent = true, spent_by = $1 WHERE txid = $2 AND vout = $3
`

type MarkVtxoAsSpentParams struct {
	SpentBy string
	Txid    string
	Vout    int32
}

func (q *Queries) MarkVtxoAsSpent(ctx context.Context, arg MarkVtxoAsSpentParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsSpent, arg.SpentBy, arg.Txid, arg.Vout)
	return err
}

const markVtxoAsSwept = `-- name: MarkVtxoAsSwept :exec
UPDATE vtxo SET swept = true WHERE txid = $1 AND vout = $2
`

type MarkVtxoAsSweptParams struct {
	Txid string
	Vout int32
}

func (q *Queries) MarkVtxoAsSwept(ctx context.Context, arg MarkVtxoAsSweptParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsSwept, arg.Txid, arg.Vout)
	return err
}

const selectAllVtxos = `-- name: SelectAllVtxos :many
SELECT vtxo_virtual_tx_vw.txid, vtxo_virtual_tx_vw.vout, vtxo_virtual_tx_vw.pubkey, vtxo_virtual_tx_vw.amount, vtxo_virtual_tx_vw.commitment_txid, vtxo_virtual_tx_vw.spent_by, vtxo_virtual_tx_vw.spent, vtxo_virtual_tx_vw.redeemed, vtxo_virtual_tx_vw.swept, vtxo_virtual_tx_vw.expire_at, vtxo_virtual_tx_vw.created_at, vtxo_virtual_tx_vw.request_id, vtxo_virtual_tx_vw.redeem_tx FROM vtxo_virtual_tx_vw
`

type SelectAllVtxosRow struct {
	VtxoVirtualTxVw VtxoVirtualTxVw
}

func (q *Queries) SelectAllVtxos(ctx context.Context) ([]SelectAllVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectAllVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllVtxosRow
	for rows.Next() {
		var i SelectAllVtxosRow
		if err := rows.Scan(
			&i.VtxoVirtualTxVw.Txid,
			&i.VtxoVirtualTxVw.Vout,
			&i.VtxoVirtualTxVw.Pubkey,
			&i.VtxoVirtualTxVw.Amount,
			&i.VtxoVirtualTxVw.CommitmentTxid,
			&i.VtxoVirtualTxVw.SpentBy,
			&i.VtxoVirtualTxVw.Spent,
			&i.VtxoVirtualTxVw.Redeemed,
			&i.VtxoVirtualTxVw.Swept,
			&i.VtxoVirtualTxVw.ExpireAt,
			&i.VtxoVirtualTxVw.CreatedAt,
			&i.VtxoVirtualTxVw.RequestID,
			&i.VtxoVirtualTxVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectExpiredRoundsTxid = `-- name: SelectExpiredRoundsTxid :many
SELECT txid FROM round_commitment_tx_vw r
WHERE r.swept = false AND r.ended = true AND r.failed = false
`

func (q *Queries) SelectExpiredRoundsTxid(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectExpiredRoundsTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectLeafVtxosByRoundTxid = `-- name: SelectLeafVtxosByRoundTxid :many
SELECT vtxo_virtual_tx_vw.txid, vtxo_virtual_tx_vw.vout, vtxo_virtual_tx_vw.pubkey, vtxo_virtual_tx_vw.amount, vtxo_virtual_tx_vw.commitment_txid, vtxo_virtual_tx_vw.spent_by, vtxo_virtual_tx_vw.spent, vtxo_virtual_tx_vw.redeemed, vtxo_virtual_tx_vw.swept, vtxo_virtual_tx_vw.expire_at, vtxo_virtual_tx_vw.created_at, vtxo_virtual_tx_vw.request_id, vtxo_virtual_tx_vw.redeem_tx FROM vtxo_virtual_tx_vw
WHERE commitment_txid = $1 AND (redeem_tx IS NULL or redeem_tx = '')
`

type SelectLeafVtxosByRoundTxidRow struct {
	VtxoVirtualTxVw VtxoVirtualTxVw
}

func (q *Queries) SelectLeafVtxosByRoundTxid(ctx context.Context, commitmentTxid string) ([]SelectLeafVtxosByRoundTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectLeafVtxosByRoundTxid, commitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectLeafVtxosByRoundTxidRow
	for rows.Next() {
		var i SelectLeafVtxosByRoundTxidRow
		if err := rows.Scan(
			&i.VtxoVirtualTxVw.Txid,
			&i.VtxoVirtualTxVw.Vout,
			&i.VtxoVirtualTxVw.Pubkey,
			&i.VtxoVirtualTxVw.Amount,
			&i.VtxoVirtualTxVw.CommitmentTxid,
			&i.VtxoVirtualTxVw.SpentBy,
			&i.VtxoVirtualTxVw.Spent,
			&i.VtxoVirtualTxVw.Redeemed,
			&i.VtxoVirtualTxVw.Swept,
			&i.VtxoVirtualTxVw.ExpireAt,
			&i.VtxoVirtualTxVw.CreatedAt,
			&i.VtxoVirtualTxVw.RequestID,
			&i.VtxoVirtualTxVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotRedeemedVtxos = `-- name: SelectNotRedeemedVtxos :many
SELECT vtxo_virtual_tx_vw.txid, vtxo_virtual_tx_vw.vout, vtxo_virtual_tx_vw.pubkey, vtxo_virtual_tx_vw.amount, vtxo_virtual_tx_vw.commitment_txid, vtxo_virtual_tx_vw.spent_by, vtxo_virtual_tx_vw.spent, vtxo_virtual_tx_vw.redeemed, vtxo_virtual_tx_vw.swept, vtxo_virtual_tx_vw.expire_at, vtxo_virtual_tx_vw.created_at, vtxo_virtual_tx_vw.request_id, vtxo_virtual_tx_vw.redeem_tx FROM vtxo_virtual_tx_vw
WHERE redeemed = false
`

type SelectNotRedeemedVtxosRow struct {
	VtxoVirtualTxVw VtxoVirtualTxVw
}

func (q *Queries) SelectNotRedeemedVtxos(ctx context.Context) ([]SelectNotRedeemedVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotRedeemedVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotRedeemedVtxosRow
	for rows.Next() {
		var i SelectNotRedeemedVtxosRow
		if err := rows.Scan(
			&i.VtxoVirtualTxVw.Txid,
			&i.VtxoVirtualTxVw.Vout,
			&i.VtxoVirtualTxVw.Pubkey,
			&i.VtxoVirtualTxVw.Amount,
			&i.VtxoVirtualTxVw.CommitmentTxid,
			&i.VtxoVirtualTxVw.SpentBy,
			&i.VtxoVirtualTxVw.Spent,
			&i.VtxoVirtualTxVw.Redeemed,
			&i.VtxoVirtualTxVw.Swept,
			&i.VtxoVirtualTxVw.ExpireAt,
			&i.VtxoVirtualTxVw.CreatedAt,
			&i.VtxoVirtualTxVw.RequestID,
			&i.VtxoVirtualTxVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotRedeemedVtxosWithPubkey = `-- name: SelectNotRedeemedVtxosWithPubkey :many
SELECT vtxo_virtual_tx_vw.txid, vtxo_virtual_tx_vw.vout, vtxo_virtual_tx_vw.pubkey, vtxo_virtual_tx_vw.amount, vtxo_virtual_tx_vw.commitment_txid, vtxo_virtual_tx_vw.spent_by, vtxo_virtual_tx_vw.spent, vtxo_virtual_tx_vw.redeemed, vtxo_virtual_tx_vw.swept, vtxo_virtual_tx_vw.expire_at, vtxo_virtual_tx_vw.created_at, vtxo_virtual_tx_vw.request_id, vtxo_virtual_tx_vw.redeem_tx FROM vtxo_virtual_tx_vw
WHERE redeemed = false AND pubkey = $1
`

type SelectNotRedeemedVtxosWithPubkeyRow struct {
	VtxoVirtualTxVw VtxoVirtualTxVw
}

func (q *Queries) SelectNotRedeemedVtxosWithPubkey(ctx context.Context, pubkey string) ([]SelectNotRedeemedVtxosWithPubkeyRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotRedeemedVtxosWithPubkey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotRedeemedVtxosWithPubkeyRow
	for rows.Next() {
		var i SelectNotRedeemedVtxosWithPubkeyRow
		if err := rows.Scan(
			&i.VtxoVirtualTxVw.Txid,
			&i.VtxoVirtualTxVw.Vout,
			&i.VtxoVirtualTxVw.Pubkey,
			&i.VtxoVirtualTxVw.Amount,
			&i.VtxoVirtualTxVw.CommitmentTxid,
			&i.VtxoVirtualTxVw.SpentBy,
			&i.VtxoVirtualTxVw.Spent,
			&i.VtxoVirtualTxVw.Redeemed,
			&i.VtxoVirtualTxVw.Swept,
			&i.VtxoVirtualTxVw.ExpireAt,
			&i.VtxoVirtualTxVw.CreatedAt,
			&i.VtxoVirtualTxVw.RequestID,
			&i.VtxoVirtualTxVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIds = `-- name: SelectRoundIds :many
SELECT id FROM round
`

func (q *Queries) SelectRoundIds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsInRange = `-- name: SelectRoundIdsInRange :many
SELECT id FROM round WHERE starting_timestamp > $1 AND starting_timestamp < $2
`

type SelectRoundIdsInRangeParams struct {
	StartTs int64
	EndTs   int64
}

func (q *Queries) SelectRoundIdsInRange(ctx context.Context, arg SelectRoundIdsInRangeParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsInRange, arg.StartTs, arg.EndTs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithRoundId = `-- name: SelectRoundWithRoundId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration,
       round_request_vw.id, round_request_vw.round_id,
       round_tx_vw.txid, round_tx_vw.tx, round_tx_vw.round_id, round_tx_vw.type, round_tx_vw.position, round_tx_vw.children,
       request_receiver_vw.request_id, request_receiver_vw.pubkey, request_receiver_vw.onchain_address, request_receiver_vw.amount,
       request_vtxo_vw.txid, request_vtxo_vw.vout, request_vtxo_vw.pubkey, request_vtxo_vw.amount, request_vtxo_vw.commitment_txid, request_vtxo_vw.spent_by, request_vtxo_vw.spent, request_vtxo_vw.redeemed, request_vtxo_vw.swept, request_vtxo_vw.expire_at, request_vtxo_vw.created_at, request_vtxo_vw.request_id
FROM round
         LEFT OUTER JOIN round_request_vw ON round.id=round_request_vw.round_id
         LEFT OUTER JOIN round_tx_vw ON round.id=round_tx_vw.round_id
         LEFT OUTER JOIN request_receiver_vw ON round_request_vw.id=request_receiver_vw.request_id
         LEFT OUTER JOIN request_vtxo_vw ON round_request_vw.id=request_vtxo_vw.request_id
WHERE round.id = $1
`

type SelectRoundWithRoundIdRow struct {
	Round             Round
	RoundRequestVw    RoundRequestVw
	RoundTxVw         RoundTxVw
	RequestReceiverVw RequestReceiverVw
	RequestVtxoVw     RequestVtxoVw
}

func (q *Queries) SelectRoundWithRoundId(ctx context.Context, id string) ([]SelectRoundWithRoundIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithRoundId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithRoundIdRow
	for rows.Next() {
		var i SelectRoundWithRoundIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.RoundRequestVw.ID,
			&i.RoundRequestVw.RoundID,
			&i.RoundTxVw.Txid,
			&i.RoundTxVw.Tx,
			&i.RoundTxVw.RoundID,
			&i.RoundTxVw.Type,
			&i.RoundTxVw.Position,
			&i.RoundTxVw.Children,
			&i.RequestReceiverVw.RequestID,
			&i.RequestReceiverVw.Pubkey,
			&i.RequestReceiverVw.OnchainAddress,
			&i.RequestReceiverVw.Amount,
			&i.RequestVtxoVw.Txid,
			&i.RequestVtxoVw.Vout,
			&i.RequestVtxoVw.Pubkey,
			&i.RequestVtxoVw.Amount,
			&i.RequestVtxoVw.CommitmentTxid,
			&i.RequestVtxoVw.SpentBy,
			&i.RequestVtxoVw.Spent,
			&i.RequestVtxoVw.Redeemed,
			&i.RequestVtxoVw.Swept,
			&i.RequestVtxoVw.ExpireAt,
			&i.RequestVtxoVw.CreatedAt,
			&i.RequestVtxoVw.RequestID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithRoundTxId = `-- name: SelectRoundWithRoundTxId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration,
       round_request_vw.id, round_request_vw.round_id,
       round_tx_vw.txid, round_tx_vw.tx, round_tx_vw.round_id, round_tx_vw.type, round_tx_vw.position, round_tx_vw.children,
       request_receiver_vw.request_id, request_receiver_vw.pubkey, request_receiver_vw.onchain_address, request_receiver_vw.amount,
       request_vtxo_vw.txid, request_vtxo_vw.vout, request_vtxo_vw.pubkey, request_vtxo_vw.amount, request_vtxo_vw.commitment_txid, request_vtxo_vw.spent_by, request_vtxo_vw.spent, request_vtxo_vw.redeemed, request_vtxo_vw.swept, request_vtxo_vw.expire_at, request_vtxo_vw.created_at, request_vtxo_vw.request_id
FROM round
         LEFT OUTER JOIN round_request_vw ON round.id=round_request_vw.round_id
         LEFT OUTER JOIN round_tx_vw ON round.id=round_tx_vw.round_id
         LEFT OUTER JOIN request_receiver_vw ON round_request_vw.id=request_receiver_vw.request_id
         LEFT OUTER JOIN request_vtxo_vw ON round_request_vw.id=request_vtxo_vw.request_id
WHERE round.id = (
    SELECT round_id FROM round_tx_vw tx WHERE tx.txid = $1 and tx.type = 'commitment'
)
`

type SelectRoundWithRoundTxIdRow struct {
	Round             Round
	RoundRequestVw    RoundRequestVw
	RoundTxVw         RoundTxVw
	RequestReceiverVw RequestReceiverVw
	RequestVtxoVw     RequestVtxoVw
}

func (q *Queries) SelectRoundWithRoundTxId(ctx context.Context, txid sql.NullString) ([]SelectRoundWithRoundTxIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithRoundTxId, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithRoundTxIdRow
	for rows.Next() {
		var i SelectRoundWithRoundTxIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.RoundRequestVw.ID,
			&i.RoundRequestVw.RoundID,
			&i.RoundTxVw.Txid,
			&i.RoundTxVw.Tx,
			&i.RoundTxVw.RoundID,
			&i.RoundTxVw.Type,
			&i.RoundTxVw.Position,
			&i.RoundTxVw.Children,
			&i.RequestReceiverVw.RequestID,
			&i.RequestReceiverVw.Pubkey,
			&i.RequestReceiverVw.OnchainAddress,
			&i.RequestReceiverVw.Amount,
			&i.RequestVtxoVw.Txid,
			&i.RequestVtxoVw.Vout,
			&i.RequestVtxoVw.Pubkey,
			&i.RequestVtxoVw.Amount,
			&i.RequestVtxoVw.CommitmentTxid,
			&i.RequestVtxoVw.SpentBy,
			&i.RequestVtxoVw.Spent,
			&i.RequestVtxoVw.Redeemed,
			&i.RequestVtxoVw.Swept,
			&i.RequestVtxoVw.ExpireAt,
			&i.RequestVtxoVw.CreatedAt,
			&i.RequestVtxoVw.RequestID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableVtxos = `-- name: SelectSweepableVtxos :many
SELECT vtxo_virtual_tx_vw.txid, vtxo_virtual_tx_vw.vout, vtxo_virtual_tx_vw.pubkey, vtxo_virtual_tx_vw.amount, vtxo_virtual_tx_vw.commitment_txid, vtxo_virtual_tx_vw.spent_by, vtxo_virtual_tx_vw.spent, vtxo_virtual_tx_vw.redeemed, vtxo_virtual_tx_vw.swept, vtxo_virtual_tx_vw.expire_at, vtxo_virtual_tx_vw.created_at, vtxo_virtual_tx_vw.request_id, vtxo_virtual_tx_vw.redeem_tx FROM vtxo_virtual_tx_vw
WHERE redeemed = false AND swept = false
`

type SelectSweepableVtxosRow struct {
	VtxoVirtualTxVw VtxoVirtualTxVw
}

func (q *Queries) SelectSweepableVtxos(ctx context.Context) ([]SelectSweepableVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectSweepableVtxosRow
	for rows.Next() {
		var i SelectSweepableVtxosRow
		if err := rows.Scan(
			&i.VtxoVirtualTxVw.Txid,
			&i.VtxoVirtualTxVw.Vout,
			&i.VtxoVirtualTxVw.Pubkey,
			&i.VtxoVirtualTxVw.Amount,
			&i.VtxoVirtualTxVw.CommitmentTxid,
			&i.VtxoVirtualTxVw.SpentBy,
			&i.VtxoVirtualTxVw.Spent,
			&i.VtxoVirtualTxVw.Redeemed,
			&i.VtxoVirtualTxVw.Swept,
			&i.VtxoVirtualTxVw.ExpireAt,
			&i.VtxoVirtualTxVw.CreatedAt,
			&i.VtxoVirtualTxVw.RequestID,
			&i.VtxoVirtualTxVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweptRoundsConnectorAddress = `-- name: SelectSweptRoundsConnectorAddress :many
SELECT round.connector_address FROM round
WHERE round.swept = true AND round.failed = false AND round.ended = true AND round.connector_address <> ''
`

func (q *Queries) SelectSweptRoundsConnectorAddress(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweptRoundsConnectorAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var connector_address string
		if err := rows.Scan(&connector_address); err != nil {
			return nil, err
		}
		items = append(items, connector_address)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTreeTxsWithRoundTxid = `-- name: SelectTreeTxsWithRoundTxid :many
SELECT txid, tx, round_id, type, position, children FROM tx
WHERE round_id IN (SELECT rctv.round_id FROM round_commitment_tx_vw rctv WHERE rctv.txid = $1) AND type = 'tree'
`

func (q *Queries) SelectTreeTxsWithRoundTxid(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectTreeTxsWithRoundTxid, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUnsweptRoundsTxid = `-- name: SelectUnsweptRoundsTxid :many
SELECT txid FROM round_commitment_tx_vw r
WHERE r.swept = false AND r.ended = true AND r.failed = false
`

func (q *Queries) SelectUnsweptRoundsTxid(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectUnsweptRoundsTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVirtualTxWithTxId = `-- name: SelectVirtualTxWithTxId :many
SELECT  virtual_tx_checkpoint_tx_vw.txid, virtual_tx_checkpoint_tx_vw.tx, virtual_tx_checkpoint_tx_vw.starting_timestamp, virtual_tx_checkpoint_tx_vw.ending_timestamp, virtual_tx_checkpoint_tx_vw.expiry_timestamp, virtual_tx_checkpoint_tx_vw.fail_reason, virtual_tx_checkpoint_tx_vw.stage_code, virtual_tx_checkpoint_tx_vw.checkpoint_txid, virtual_tx_checkpoint_tx_vw.checkpoint_tx, virtual_tx_checkpoint_tx_vw.commitment_txid, virtual_tx_checkpoint_tx_vw.is_root_commitment_txid, virtual_tx_checkpoint_tx_vw.virtual_txid
FROM virtual_tx_checkpoint_tx_vw WHERE txid = $1
`

type SelectVirtualTxWithTxIdRow struct {
	VirtualTxCheckpointTxVw VirtualTxCheckpointTxVw
}

func (q *Queries) SelectVirtualTxWithTxId(ctx context.Context, txid string) ([]SelectVirtualTxWithTxIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVirtualTxWithTxId, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVirtualTxWithTxIdRow
	for rows.Next() {
		var i SelectVirtualTxWithTxIdRow
		if err := rows.Scan(
			&i.VirtualTxCheckpointTxVw.Txid,
			&i.VirtualTxCheckpointTxVw.Tx,
			&i.VirtualTxCheckpointTxVw.StartingTimestamp,
			&i.VirtualTxCheckpointTxVw.EndingTimestamp,
			&i.VirtualTxCheckpointTxVw.ExpiryTimestamp,
			&i.VirtualTxCheckpointTxVw.FailReason,
			&i.VirtualTxCheckpointTxVw.StageCode,
			&i.VirtualTxCheckpointTxVw.CheckpointTxid,
			&i.VirtualTxCheckpointTxVw.CheckpointTx,
			&i.VirtualTxCheckpointTxVw.CommitmentTxid,
			&i.VirtualTxCheckpointTxVw.IsRootCommitmentTxid,
			&i.VirtualTxCheckpointTxVw.VirtualTxid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxoByOutpoint = `-- name: SelectVtxoByOutpoint :one
SELECT vtxo_virtual_tx_vw.txid, vtxo_virtual_tx_vw.vout, vtxo_virtual_tx_vw.pubkey, vtxo_virtual_tx_vw.amount, vtxo_virtual_tx_vw.commitment_txid, vtxo_virtual_tx_vw.spent_by, vtxo_virtual_tx_vw.spent, vtxo_virtual_tx_vw.redeemed, vtxo_virtual_tx_vw.swept, vtxo_virtual_tx_vw.expire_at, vtxo_virtual_tx_vw.created_at, vtxo_virtual_tx_vw.request_id, vtxo_virtual_tx_vw.redeem_tx FROM vtxo_virtual_tx_vw
WHERE txid = $1 AND vout = $2
`

type SelectVtxoByOutpointParams struct {
	Txid string
	Vout int32
}

type SelectVtxoByOutpointRow struct {
	VtxoVirtualTxVw VtxoVirtualTxVw
}

func (q *Queries) SelectVtxoByOutpoint(ctx context.Context, arg SelectVtxoByOutpointParams) (SelectVtxoByOutpointRow, error) {
	row := q.db.QueryRowContext(ctx, selectVtxoByOutpoint, arg.Txid, arg.Vout)
	var i SelectVtxoByOutpointRow
	err := row.Scan(
		&i.VtxoVirtualTxVw.Txid,
		&i.VtxoVirtualTxVw.Vout,
		&i.VtxoVirtualTxVw.Pubkey,
		&i.VtxoVirtualTxVw.Amount,
		&i.VtxoVirtualTxVw.CommitmentTxid,
		&i.VtxoVirtualTxVw.SpentBy,
		&i.VtxoVirtualTxVw.Spent,
		&i.VtxoVirtualTxVw.Redeemed,
		&i.VtxoVirtualTxVw.Swept,
		&i.VtxoVirtualTxVw.ExpireAt,
		&i.VtxoVirtualTxVw.CreatedAt,
		&i.VtxoVirtualTxVw.RequestID,
		&i.VtxoVirtualTxVw.RedeemTx,
	)
	return i, err
}

const selectVtxosByRoundTxid = `-- name: SelectVtxosByRoundTxid :many
SELECT vtxo_virtual_tx_vw.txid, vtxo_virtual_tx_vw.vout, vtxo_virtual_tx_vw.pubkey, vtxo_virtual_tx_vw.amount, vtxo_virtual_tx_vw.commitment_txid, vtxo_virtual_tx_vw.spent_by, vtxo_virtual_tx_vw.spent, vtxo_virtual_tx_vw.redeemed, vtxo_virtual_tx_vw.swept, vtxo_virtual_tx_vw.expire_at, vtxo_virtual_tx_vw.created_at, vtxo_virtual_tx_vw.request_id, vtxo_virtual_tx_vw.redeem_tx FROM vtxo_virtual_tx_vw
WHERE commitment_txid = $1
`

type SelectVtxosByRoundTxidRow struct {
	VtxoVirtualTxVw VtxoVirtualTxVw
}

func (q *Queries) SelectVtxosByRoundTxid(ctx context.Context, commitmentTxid string) ([]SelectVtxosByRoundTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosByRoundTxid, commitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosByRoundTxidRow
	for rows.Next() {
		var i SelectVtxosByRoundTxidRow
		if err := rows.Scan(
			&i.VtxoVirtualTxVw.Txid,
			&i.VtxoVirtualTxVw.Vout,
			&i.VtxoVirtualTxVw.Pubkey,
			&i.VtxoVirtualTxVw.Amount,
			&i.VtxoVirtualTxVw.CommitmentTxid,
			&i.VtxoVirtualTxVw.SpentBy,
			&i.VtxoVirtualTxVw.Spent,
			&i.VtxoVirtualTxVw.Redeemed,
			&i.VtxoVirtualTxVw.Swept,
			&i.VtxoVirtualTxVw.ExpireAt,
			&i.VtxoVirtualTxVw.CreatedAt,
			&i.VtxoVirtualTxVw.RequestID,
			&i.VtxoVirtualTxVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosWithPubkey = `-- name: SelectVtxosWithPubkey :many
SELECT vtxo_virtual_tx_vw.txid, vtxo_virtual_tx_vw.vout, vtxo_virtual_tx_vw.pubkey, vtxo_virtual_tx_vw.amount, vtxo_virtual_tx_vw.commitment_txid, vtxo_virtual_tx_vw.spent_by, vtxo_virtual_tx_vw.spent, vtxo_virtual_tx_vw.redeemed, vtxo_virtual_tx_vw.swept, vtxo_virtual_tx_vw.expire_at, vtxo_virtual_tx_vw.created_at, vtxo_virtual_tx_vw.request_id, vtxo_virtual_tx_vw.redeem_tx FROM vtxo_virtual_tx_vw WHERE pubkey = $1
`

type SelectVtxosWithPubkeyRow struct {
	VtxoVirtualTxVw VtxoVirtualTxVw
}

func (q *Queries) SelectVtxosWithPubkey(ctx context.Context, pubkey string) ([]SelectVtxosWithPubkeyRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosWithPubkey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosWithPubkeyRow
	for rows.Next() {
		var i SelectVtxosWithPubkeyRow
		if err := rows.Scan(
			&i.VtxoVirtualTxVw.Txid,
			&i.VtxoVirtualTxVw.Vout,
			&i.VtxoVirtualTxVw.Pubkey,
			&i.VtxoVirtualTxVw.Amount,
			&i.VtxoVirtualTxVw.CommitmentTxid,
			&i.VtxoVirtualTxVw.SpentBy,
			&i.VtxoVirtualTxVw.Spent,
			&i.VtxoVirtualTxVw.Redeemed,
			&i.VtxoVirtualTxVw.Swept,
			&i.VtxoVirtualTxVw.ExpireAt,
			&i.VtxoVirtualTxVw.CreatedAt,
			&i.VtxoVirtualTxVw.RequestID,
			&i.VtxoVirtualTxVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVtxoExpireAt = `-- name: UpdateVtxoExpireAt :exec
UPDATE vtxo SET expire_at = $1 WHERE txid = $2 AND vout = $3
`

type UpdateVtxoExpireAtParams struct {
	ExpireAt int64
	Txid     string
	Vout     int32
}

func (q *Queries) UpdateVtxoExpireAt(ctx context.Context, arg UpdateVtxoExpireAtParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoExpireAt, arg.ExpireAt, arg.Txid, arg.Vout)
	return err
}

const updateVtxoRequestId = `-- name: UpdateVtxoRequestId :exec
UPDATE vtxo SET request_id = $1 WHERE txid = $2 AND vout = $3
`

type UpdateVtxoRequestIdParams struct {
	RequestID sql.NullString
	Txid      string
	Vout      int32
}

func (q *Queries) UpdateVtxoRequestId(ctx context.Context, arg UpdateVtxoRequestIdParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoRequestId, arg.RequestID, arg.Txid, arg.Vout)
	return err
}

const upsertCheckpointTx = `-- name: UpsertCheckpointTx :exec
INSERT INTO checkpoint_tx (
    txid, tx, commitment_txid, is_root_commitment_txid, virtual_txid
) VALUES ($1, $2, $3, $4, $5)
    ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    commitment_txid = EXCLUDED.commitment_txid,
    is_root_commitment_txid = EXCLUDED.is_root_commitment_txid,
    virtual_txid = EXCLUDED.virtual_txid
`

type UpsertCheckpointTxParams struct {
	Txid                 string
	Tx                   string
	CommitmentTxid       string
	IsRootCommitmentTxid bool
	VirtualTxid          string
}

func (q *Queries) UpsertCheckpointTx(ctx context.Context, arg UpsertCheckpointTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertCheckpointTx,
		arg.Txid,
		arg.Tx,
		arg.CommitmentTxid,
		arg.IsRootCommitmentTxid,
		arg.VirtualTxid,
	)
	return err
}

const upsertMarketHour = `-- name: UpsertMarketHour :exec
INSERT INTO market_hour (
    id, start_time, end_time, period, round_interval, updated_at
) VALUES (
             $1, $2, $3, $4, $5, $6
         )
    ON CONFLICT (id) DO UPDATE SET
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    period = EXCLUDED.period,
    round_interval = EXCLUDED.round_interval,
    updated_at = EXCLUDED.updated_at
`

type UpsertMarketHourParams struct {
	ID            int32
	StartTime     int64
	EndTime       int64
	Period        int64
	RoundInterval int64
	UpdatedAt     int64
}

func (q *Queries) UpsertMarketHour(ctx context.Context, arg UpsertMarketHourParams) error {
	_, err := q.db.ExecContext(ctx, upsertMarketHour,
		arg.ID,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.RoundInterval,
		arg.UpdatedAt,
	)
	return err
}

const upsertReceiver = `-- name: UpsertReceiver :exec
INSERT INTO receiver (request_id, pubkey, onchain_address, amount) VALUES ($1, $2, $3, $4)
    ON CONFLICT(request_id, pubkey, onchain_address) DO UPDATE SET
    amount = EXCLUDED.amount,
    pubkey = EXCLUDED.pubkey,
    onchain_address = EXCLUDED.onchain_address
`

type UpsertReceiverParams struct {
	RequestID      string
	Pubkey         string
	OnchainAddress string
	Amount         int64
}

func (q *Queries) UpsertReceiver(ctx context.Context, arg UpsertReceiverParams) error {
	_, err := q.db.ExecContext(ctx, upsertReceiver,
		arg.RequestID,
		arg.Pubkey,
		arg.OnchainAddress,
		arg.Amount,
	)
	return err
}

const upsertRound = `-- name: UpsertRound :exec
INSERT INTO round (
    id,
    starting_timestamp,
    ending_timestamp,
    ended, failed,
    stage_code,
    connector_address,
    version,
    swept,
    vtxo_tree_expiration
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
    ON CONFLICT(id) DO UPDATE SET
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    ended = EXCLUDED.ended,
    failed = EXCLUDED.failed,
    stage_code = EXCLUDED.stage_code,
    connector_address = EXCLUDED.connector_address,
    version = EXCLUDED.version,
    swept = EXCLUDED.swept,
    vtxo_tree_expiration = EXCLUDED.vtxo_tree_expiration
`

type UpsertRoundParams struct {
	ID                 string
	StartingTimestamp  int64
	EndingTimestamp    int64
	Ended              bool
	Failed             bool
	StageCode          int32
	ConnectorAddress   string
	Version            int32
	Swept              bool
	VtxoTreeExpiration int64
}

func (q *Queries) UpsertRound(ctx context.Context, arg UpsertRoundParams) error {
	_, err := q.db.ExecContext(ctx, upsertRound,
		arg.ID,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.Ended,
		arg.Failed,
		arg.StageCode,
		arg.ConnectorAddress,
		arg.Version,
		arg.Swept,
		arg.VtxoTreeExpiration,
	)
	return err
}

const upsertTransaction = `-- name: UpsertTransaction :exec
INSERT INTO tx (
    tx, round_id, type, position, txid, children
) VALUES ($1, $2, $3, $4, $5, $6)
    ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    round_id = EXCLUDED.round_id,
    type = EXCLUDED.type,
    position = EXCLUDED.position,
    txid = EXCLUDED.txid,
    children = EXCLUDED.children
`

type UpsertTransactionParams struct {
	Tx       string
	RoundID  string
	Type     string
	Position int32
	Txid     string
	Children pqtype.NullRawMessage
}

func (q *Queries) UpsertTransaction(ctx context.Context, arg UpsertTransactionParams) error {
	_, err := q.db.ExecContext(ctx, upsertTransaction,
		arg.Tx,
		arg.RoundID,
		arg.Type,
		arg.Position,
		arg.Txid,
		arg.Children,
	)
	return err
}

const upsertTxRequest = `-- name: UpsertTxRequest :exec
INSERT INTO tx_request (id, round_id) VALUES ($1, $2)
    ON CONFLICT(id) DO UPDATE SET round_id = EXCLUDED.round_id
`

type UpsertTxRequestParams struct {
	ID      string
	RoundID string
}

func (q *Queries) UpsertTxRequest(ctx context.Context, arg UpsertTxRequestParams) error {
	_, err := q.db.ExecContext(ctx, upsertTxRequest, arg.ID, arg.RoundID)
	return err
}

const upsertVirtualTx = `-- name: UpsertVirtualTx :exec
INSERT INTO virtual_tx (
    txid, tx, starting_timestamp, ending_timestamp, expiry_timestamp, fail_reason, stage_code
) VALUES ($1, $2, $3, $4, $5, $6, $7)
    ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    expiry_timestamp = EXCLUDED.expiry_timestamp,
    fail_reason = EXCLUDED.fail_reason,
    stage_code = EXCLUDED.stage_code
`

type UpsertVirtualTxParams struct {
	Txid              string
	Tx                string
	StartingTimestamp int64
	EndingTimestamp   int64
	ExpiryTimestamp   int64
	FailReason        sql.NullString
	StageCode         int32
}

func (q *Queries) UpsertVirtualTx(ctx context.Context, arg UpsertVirtualTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertVirtualTx,
		arg.Txid,
		arg.Tx,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.ExpiryTimestamp,
		arg.FailReason,
		arg.StageCode,
	)
	return err
}

const upsertVtxo = `-- name: UpsertVtxo :exec
INSERT INTO vtxo (txid, vout, pubkey, amount, commitment_txid, spent_by, spent, redeemed, swept, expire_at, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) ON CONFLICT(txid, vout) DO UPDATE SET
    pubkey = EXCLUDED.pubkey,
    amount = EXCLUDED.amount,
    commitment_txid = EXCLUDED.commitment_txid,
    spent_by = EXCLUDED.spent_by,
    spent = EXCLUDED.spent,
    redeemed = EXCLUDED.redeemed,
    swept = EXCLUDED.swept,
    expire_at = EXCLUDED.expire_at,
    created_at = EXCLUDED.created_at
`

type UpsertVtxoParams struct {
	Txid           string
	Vout           int32
	Pubkey         string
	Amount         int64
	CommitmentTxid string
	SpentBy        string
	Spent          bool
	Redeemed       bool
	Swept          bool
	ExpireAt       int64
	CreatedAt      int64
}

func (q *Queries) UpsertVtxo(ctx context.Context, arg UpsertVtxoParams) error {
	_, err := q.db.ExecContext(ctx, upsertVtxo,
		arg.Txid,
		arg.Vout,
		arg.Pubkey,
		arg.Amount,
		arg.CommitmentTxid,
		arg.SpentBy,
		arg.Spent,
		arg.Redeemed,
		arg.Swept,
		arg.ExpireAt,
		arg.CreatedAt,
	)
	return err
}
