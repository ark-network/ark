// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
)

const containsNote = `-- name: ContainsNote :one
SELECT EXISTS(SELECT 1 FROM note WHERE id = ?)
`

func (q *Queries) ContainsNote(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, containsNote, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteEntity = `-- name: DeleteEntity :exec
DELETE FROM entity WHERE id = ?
`

func (q *Queries) DeleteEntity(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEntity, id)
	return err
}

const deleteEntityVtxo = `-- name: DeleteEntityVtxo :exec
DELETE FROM entity_vtxo WHERE entity_id = ?
`

func (q *Queries) DeleteEntityVtxo(ctx context.Context, entityID int64) error {
	_, err := q.db.ExecContext(ctx, deleteEntityVtxo, entityID)
	return err
}

const getLatestMarketHour = `-- name: GetLatestMarketHour :one
SELECT id, start_time, end_time, period, round_interval, updated_at FROM market_hour ORDER BY updated_at DESC LIMIT 1
`

func (q *Queries) GetLatestMarketHour(ctx context.Context) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, getLatestMarketHour)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const insertMarketHour = `-- name: InsertMarketHour :one
INSERT INTO market_hour (
    start_time,
    end_time,
    period,
    round_interval,
    updated_at
) VALUES (?, ?, ?, ?, ?)
RETURNING id, start_time, end_time, period, round_interval, updated_at
`

type InsertMarketHourParams struct {
	StartTime     int64
	EndTime       int64
	Period        int64
	RoundInterval int64
	UpdatedAt     int64
}

func (q *Queries) InsertMarketHour(ctx context.Context, arg InsertMarketHourParams) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, insertMarketHour,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.RoundInterval,
		arg.UpdatedAt,
	)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const insertNote = `-- name: InsertNote :exec
INSERT INTO note (id) VALUES (?)
`

func (q *Queries) InsertNote(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, insertNote, id)
	return err
}

const markVtxoAsRedeemed = `-- name: MarkVtxoAsRedeemed :exec
UPDATE vtxo SET redeemed = true WHERE txid = ? AND vout = ?
`

type MarkVtxoAsRedeemedParams struct {
	Txid string
	Vout int64
}

func (q *Queries) MarkVtxoAsRedeemed(ctx context.Context, arg MarkVtxoAsRedeemedParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsRedeemed, arg.Txid, arg.Vout)
	return err
}

const markVtxoAsSpent = `-- name: MarkVtxoAsSpent :exec
UPDATE vtxo SET spent = true, spent_by = ? WHERE txid = ? AND vout = ?
`

type MarkVtxoAsSpentParams struct {
	SpentBy string
	Txid    string
	Vout    int64
}

func (q *Queries) MarkVtxoAsSpent(ctx context.Context, arg MarkVtxoAsSpentParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsSpent, arg.SpentBy, arg.Txid, arg.Vout)
	return err
}

const markVtxoAsSwept = `-- name: MarkVtxoAsSwept :exec
UPDATE vtxo SET swept = true WHERE txid = ? AND vout = ?
`

type MarkVtxoAsSweptParams struct {
	Txid string
	Vout int64
}

func (q *Queries) MarkVtxoAsSwept(ctx context.Context, arg MarkVtxoAsSweptParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsSwept, arg.Txid, arg.Vout)
	return err
}

const selectEntitiesByVtxo = `-- name: SelectEntitiesByVtxo :many
SELECT entity_vw.id, entity_vw.nostr_recipient, entity_vw.vtxo_txid, entity_vw.vtxo_vout FROM entity_vw
WHERE vtxo_txid = ? AND vtxo_vout = ?
`

type SelectEntitiesByVtxoParams struct {
	VtxoTxid sql.NullString
	VtxoVout sql.NullInt64
}

type SelectEntitiesByVtxoRow struct {
	EntityVw EntityVw
}

func (q *Queries) SelectEntitiesByVtxo(ctx context.Context, arg SelectEntitiesByVtxoParams) ([]SelectEntitiesByVtxoRow, error) {
	rows, err := q.db.QueryContext(ctx, selectEntitiesByVtxo, arg.VtxoTxid, arg.VtxoVout)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectEntitiesByVtxoRow
	for rows.Next() {
		var i SelectEntitiesByVtxoRow
		if err := rows.Scan(
			&i.EntityVw.ID,
			&i.EntityVw.NostrRecipient,
			&i.EntityVw.VtxoTxid,
			&i.EntityVw.VtxoVout,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectExpiredRoundsTxid = `-- name: SelectExpiredRoundsTxid :many
SELECT round.txid FROM round
WHERE round.swept = false AND round.ended = true AND round.failed = false
`

func (q *Queries) SelectExpiredRoundsTxid(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectExpiredRoundsTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotRedeemedVtxos = `-- name: SelectNotRedeemedVtxos :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE redeemed = false
`

type SelectNotRedeemedVtxosRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectNotRedeemedVtxos(ctx context.Context) ([]SelectNotRedeemedVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotRedeemedVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotRedeemedVtxosRow
	for rows.Next() {
		var i SelectNotRedeemedVtxosRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotRedeemedVtxosWithPubkey = `-- name: SelectNotRedeemedVtxosWithPubkey :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE redeemed = false AND pubkey = ?
`

type SelectNotRedeemedVtxosWithPubkeyRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectNotRedeemedVtxosWithPubkey(ctx context.Context, pubkey string) ([]SelectNotRedeemedVtxosWithPubkeyRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotRedeemedVtxosWithPubkey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotRedeemedVtxosWithPubkeyRow
	for rows.Next() {
		var i SelectNotRedeemedVtxosWithPubkeyRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIds = `-- name: SelectRoundIds :many
SELECT id FROM round
`

func (q *Queries) SelectRoundIds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsInRange = `-- name: SelectRoundIdsInRange :many
SELECT id FROM round WHERE starting_timestamp > ? AND starting_timestamp < ?
`

type SelectRoundIdsInRangeParams struct {
	StartingTimestamp   int64
	StartingTimestamp_2 int64
}

func (q *Queries) SelectRoundIdsInRange(ctx context.Context, arg SelectRoundIdsInRangeParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsInRange, arg.StartingTimestamp, arg.StartingTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithRoundId = `-- name: SelectRoundWithRoundId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.txid, round.unsigned_tx, round.connector_address, round.dust_amount, round.version, round.swept,
       round_request_vw.id, round_request_vw.round_id,
       round_tx_vw.id, round_tx_vw.tx, round_tx_vw.round_id, round_tx_vw.type, round_tx_vw.position, round_tx_vw.txid, round_tx_vw.tree_level, round_tx_vw.parent_txid, round_tx_vw.is_leaf,
       request_receiver_vw.request_id, request_receiver_vw.pubkey, request_receiver_vw.onchain_address, request_receiver_vw.amount,
       request_vtxo_vw.txid, request_vtxo_vw.vout, request_vtxo_vw.pubkey, request_vtxo_vw.amount, request_vtxo_vw.round_tx, request_vtxo_vw.spent_by, request_vtxo_vw.spent, request_vtxo_vw.redeemed, request_vtxo_vw.swept, request_vtxo_vw.expire_at, request_vtxo_vw.created_at, request_vtxo_vw.request_id, request_vtxo_vw.redeem_tx
FROM round
         LEFT OUTER JOIN round_request_vw ON round.id=round_request_vw.round_id
         LEFT OUTER JOIN round_tx_vw ON round.id=round_tx_vw.round_id
         LEFT OUTER JOIN request_receiver_vw ON round_request_vw.id=request_receiver_vw.request_id
         LEFT OUTER JOIN request_vtxo_vw ON round_request_vw.id=request_vtxo_vw.request_id
WHERE round.id = ?
`

type SelectRoundWithRoundIdRow struct {
	Round             Round
	RoundRequestVw    RoundRequestVw
	RoundTxVw         RoundTxVw
	RequestReceiverVw RequestReceiverVw
	RequestVtxoVw     RequestVtxoVw
}

func (q *Queries) SelectRoundWithRoundId(ctx context.Context, id string) ([]SelectRoundWithRoundIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithRoundId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithRoundIdRow
	for rows.Next() {
		var i SelectRoundWithRoundIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.Txid,
			&i.Round.UnsignedTx,
			&i.Round.ConnectorAddress,
			&i.Round.DustAmount,
			&i.Round.Version,
			&i.Round.Swept,
			&i.RoundRequestVw.ID,
			&i.RoundRequestVw.RoundID,
			&i.RoundTxVw.ID,
			&i.RoundTxVw.Tx,
			&i.RoundTxVw.RoundID,
			&i.RoundTxVw.Type,
			&i.RoundTxVw.Position,
			&i.RoundTxVw.Txid,
			&i.RoundTxVw.TreeLevel,
			&i.RoundTxVw.ParentTxid,
			&i.RoundTxVw.IsLeaf,
			&i.RequestReceiverVw.RequestID,
			&i.RequestReceiverVw.Pubkey,
			&i.RequestReceiverVw.OnchainAddress,
			&i.RequestReceiverVw.Amount,
			&i.RequestVtxoVw.Txid,
			&i.RequestVtxoVw.Vout,
			&i.RequestVtxoVw.Pubkey,
			&i.RequestVtxoVw.Amount,
			&i.RequestVtxoVw.RoundTx,
			&i.RequestVtxoVw.SpentBy,
			&i.RequestVtxoVw.Spent,
			&i.RequestVtxoVw.Redeemed,
			&i.RequestVtxoVw.Swept,
			&i.RequestVtxoVw.ExpireAt,
			&i.RequestVtxoVw.CreatedAt,
			&i.RequestVtxoVw.RequestID,
			&i.RequestVtxoVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithRoundTxId = `-- name: SelectRoundWithRoundTxId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.txid, round.unsigned_tx, round.connector_address, round.dust_amount, round.version, round.swept,
       round_request_vw.id, round_request_vw.round_id,
       round_tx_vw.id, round_tx_vw.tx, round_tx_vw.round_id, round_tx_vw.type, round_tx_vw.position, round_tx_vw.txid, round_tx_vw.tree_level, round_tx_vw.parent_txid, round_tx_vw.is_leaf,
       request_receiver_vw.request_id, request_receiver_vw.pubkey, request_receiver_vw.onchain_address, request_receiver_vw.amount,
       request_vtxo_vw.txid, request_vtxo_vw.vout, request_vtxo_vw.pubkey, request_vtxo_vw.amount, request_vtxo_vw.round_tx, request_vtxo_vw.spent_by, request_vtxo_vw.spent, request_vtxo_vw.redeemed, request_vtxo_vw.swept, request_vtxo_vw.expire_at, request_vtxo_vw.created_at, request_vtxo_vw.request_id, request_vtxo_vw.redeem_tx
FROM round
         LEFT OUTER JOIN round_request_vw ON round.id=round_request_vw.round_id
         LEFT OUTER JOIN round_tx_vw ON round.id=round_tx_vw.round_id
         LEFT OUTER JOIN request_receiver_vw ON round_request_vw.id=request_receiver_vw.request_id
         LEFT OUTER JOIN request_vtxo_vw ON round_request_vw.id=request_vtxo_vw.request_id
WHERE round.txid = ?
`

type SelectRoundWithRoundTxIdRow struct {
	Round             Round
	RoundRequestVw    RoundRequestVw
	RoundTxVw         RoundTxVw
	RequestReceiverVw RequestReceiverVw
	RequestVtxoVw     RequestVtxoVw
}

func (q *Queries) SelectRoundWithRoundTxId(ctx context.Context, txid string) ([]SelectRoundWithRoundTxIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithRoundTxId, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithRoundTxIdRow
	for rows.Next() {
		var i SelectRoundWithRoundTxIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.Txid,
			&i.Round.UnsignedTx,
			&i.Round.ConnectorAddress,
			&i.Round.DustAmount,
			&i.Round.Version,
			&i.Round.Swept,
			&i.RoundRequestVw.ID,
			&i.RoundRequestVw.RoundID,
			&i.RoundTxVw.ID,
			&i.RoundTxVw.Tx,
			&i.RoundTxVw.RoundID,
			&i.RoundTxVw.Type,
			&i.RoundTxVw.Position,
			&i.RoundTxVw.Txid,
			&i.RoundTxVw.TreeLevel,
			&i.RoundTxVw.ParentTxid,
			&i.RoundTxVw.IsLeaf,
			&i.RequestReceiverVw.RequestID,
			&i.RequestReceiverVw.Pubkey,
			&i.RequestReceiverVw.OnchainAddress,
			&i.RequestReceiverVw.Amount,
			&i.RequestVtxoVw.Txid,
			&i.RequestVtxoVw.Vout,
			&i.RequestVtxoVw.Pubkey,
			&i.RequestVtxoVw.Amount,
			&i.RequestVtxoVw.RoundTx,
			&i.RequestVtxoVw.SpentBy,
			&i.RequestVtxoVw.Spent,
			&i.RequestVtxoVw.Redeemed,
			&i.RequestVtxoVw.Swept,
			&i.RequestVtxoVw.ExpireAt,
			&i.RequestVtxoVw.CreatedAt,
			&i.RequestVtxoVw.RequestID,
			&i.RequestVtxoVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableVtxos = `-- name: SelectSweepableVtxos :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE redeemed = false AND swept = false
`

type SelectSweepableVtxosRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectSweepableVtxos(ctx context.Context) ([]SelectSweepableVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectSweepableVtxosRow
	for rows.Next() {
		var i SelectSweepableVtxosRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweptRoundsConnectorAddress = `-- name: SelectSweptRoundsConnectorAddress :many
SELECT round.connector_address FROM round
WHERE round.swept = true AND round.failed = false AND round.ended = true AND round.connector_address <> ''
`

func (q *Queries) SelectSweptRoundsConnectorAddress(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweptRoundsConnectorAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var connector_address string
		if err := rows.Scan(&connector_address); err != nil {
			return nil, err
		}
		items = append(items, connector_address)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTreeTxsWithRoundTxid = `-- name: SelectTreeTxsWithRoundTxid :many
SELECT tx.id, tx.tx, tx.round_id, tx.type, tx.position, tx.txid, tx.tree_level, tx.parent_txid, tx.is_leaf FROM round
LEFT OUTER JOIN tx ON round.id=tx.round_id
WHERE round.txid = ? AND tx.type = 'tree'
`

type SelectTreeTxsWithRoundTxidRow struct {
	ID         sql.NullInt64
	Tx         sql.NullString
	RoundID    sql.NullString
	Type       sql.NullString
	Position   sql.NullInt64
	Txid       sql.NullString
	TreeLevel  sql.NullInt64
	ParentTxid sql.NullString
	IsLeaf     sql.NullBool
}

func (q *Queries) SelectTreeTxsWithRoundTxid(ctx context.Context, txid string) ([]SelectTreeTxsWithRoundTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectTreeTxsWithRoundTxid, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectTreeTxsWithRoundTxidRow
	for rows.Next() {
		var i SelectTreeTxsWithRoundTxidRow
		if err := rows.Scan(
			&i.ID,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Txid,
			&i.TreeLevel,
			&i.ParentTxid,
			&i.IsLeaf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxoByOutpoint = `-- name: SelectVtxoByOutpoint :one
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE txid = ? AND vout = ?
`

type SelectVtxoByOutpointParams struct {
	Txid string
	Vout int64
}

type SelectVtxoByOutpointRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectVtxoByOutpoint(ctx context.Context, arg SelectVtxoByOutpointParams) (SelectVtxoByOutpointRow, error) {
	row := q.db.QueryRowContext(ctx, selectVtxoByOutpoint, arg.Txid, arg.Vout)
	var i SelectVtxoByOutpointRow
	err := row.Scan(
		&i.Vtxo.Txid,
		&i.Vtxo.Vout,
		&i.Vtxo.Pubkey,
		&i.Vtxo.Amount,
		&i.Vtxo.RoundTx,
		&i.Vtxo.SpentBy,
		&i.Vtxo.Spent,
		&i.Vtxo.Redeemed,
		&i.Vtxo.Swept,
		&i.Vtxo.ExpireAt,
		&i.Vtxo.CreatedAt,
		&i.Vtxo.RequestID,
		&i.Vtxo.RedeemTx,
	)
	return i, err
}

const selectVtxosByRoundTxid = `-- name: SelectVtxosByRoundTxid :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE round_tx = ?
`

type SelectVtxosByRoundTxidRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectVtxosByRoundTxid(ctx context.Context, roundTx string) ([]SelectVtxosByRoundTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosByRoundTxid, roundTx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosByRoundTxidRow
	for rows.Next() {
		var i SelectVtxosByRoundTxidRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMarketHour = `-- name: UpdateMarketHour :one
UPDATE market_hour
SET start_time = ?,
    end_time = ?,
    period = ?,
    round_interval = ?,
    updated_at = ?
WHERE id = ?
RETURNING id, start_time, end_time, period, round_interval, updated_at
`

type UpdateMarketHourParams struct {
	StartTime     int64
	EndTime       int64
	Period        int64
	RoundInterval int64
	UpdatedAt     int64
	ID            int64
}

func (q *Queries) UpdateMarketHour(ctx context.Context, arg UpdateMarketHourParams) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, updateMarketHour,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.RoundInterval,
		arg.UpdatedAt,
		arg.ID,
	)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVtxoExpireAt = `-- name: UpdateVtxoExpireAt :exec
UPDATE vtxo SET expire_at = ? WHERE txid = ? AND vout = ?
`

type UpdateVtxoExpireAtParams struct {
	ExpireAt int64
	Txid     string
	Vout     int64
}

func (q *Queries) UpdateVtxoExpireAt(ctx context.Context, arg UpdateVtxoExpireAtParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoExpireAt, arg.ExpireAt, arg.Txid, arg.Vout)
	return err
}

const updateVtxoRequestId = `-- name: UpdateVtxoRequestId :exec
UPDATE vtxo SET request_id = ? WHERE txid = ? AND vout = ?
`

type UpdateVtxoRequestIdParams struct {
	RequestID sql.NullString
	Txid      string
	Vout      int64
}

func (q *Queries) UpdateVtxoRequestId(ctx context.Context, arg UpdateVtxoRequestIdParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoRequestId, arg.RequestID, arg.Txid, arg.Vout)
	return err
}

const upsertEntity = `-- name: UpsertEntity :one
INSERT INTO entity (nostr_recipient)
VALUES (?)
ON CONFLICT(nostr_recipient) DO UPDATE SET
    nostr_recipient = EXCLUDED.nostr_recipient
RETURNING id
`

func (q *Queries) UpsertEntity(ctx context.Context, nostrRecipient string) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertEntity, nostrRecipient)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertEntityVtxo = `-- name: UpsertEntityVtxo :exec
INSERT INTO entity_vtxo (entity_id, vtxo_txid, vtxo_vout)
VALUES (?, ?, ?)
ON CONFLICT(entity_id, vtxo_txid, vtxo_vout) DO UPDATE SET
    entity_id = EXCLUDED.entity_id
`

type UpsertEntityVtxoParams struct {
	EntityID int64
	VtxoTxid string
	VtxoVout int64
}

func (q *Queries) UpsertEntityVtxo(ctx context.Context, arg UpsertEntityVtxoParams) error {
	_, err := q.db.ExecContext(ctx, upsertEntityVtxo, arg.EntityID, arg.VtxoTxid, arg.VtxoVout)
	return err
}

const upsertReceiver = `-- name: UpsertReceiver :exec
INSERT INTO receiver (request_id, pubkey, onchain_address, amount) VALUES (?, ?, ?, ?)
ON CONFLICT(request_id, pubkey, onchain_address) DO UPDATE SET
    amount = EXCLUDED.amount,
    pubkey = EXCLUDED.pubkey,
    onchain_address = EXCLUDED.onchain_address
`

type UpsertReceiverParams struct {
	RequestID      string
	Pubkey         sql.NullString
	OnchainAddress sql.NullString
	Amount         int64
}

func (q *Queries) UpsertReceiver(ctx context.Context, arg UpsertReceiverParams) error {
	_, err := q.db.ExecContext(ctx, upsertReceiver,
		arg.RequestID,
		arg.Pubkey,
		arg.OnchainAddress,
		arg.Amount,
	)
	return err
}

const upsertRound = `-- name: UpsertRound :exec
INSERT INTO round (
    id,
    starting_timestamp,
    ending_timestamp,
    ended, failed,
    stage_code,
    txid,
    unsigned_tx,
    connector_address,
    dust_amount,
    version,
    swept
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    ended = EXCLUDED.ended,
    failed = EXCLUDED.failed,
    stage_code = EXCLUDED.stage_code,
    txid = EXCLUDED.txid,
    unsigned_tx = EXCLUDED.unsigned_tx,
    connector_address = EXCLUDED.connector_address,
    dust_amount = EXCLUDED.dust_amount,
    version = EXCLUDED.version,
    swept = EXCLUDED.swept
`

type UpsertRoundParams struct {
	ID                string
	StartingTimestamp int64
	EndingTimestamp   int64
	Ended             bool
	Failed            bool
	StageCode         int64
	Txid              string
	UnsignedTx        string
	ConnectorAddress  string
	DustAmount        int64
	Version           int64
	Swept             bool
}

func (q *Queries) UpsertRound(ctx context.Context, arg UpsertRoundParams) error {
	_, err := q.db.ExecContext(ctx, upsertRound,
		arg.ID,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.Ended,
		arg.Failed,
		arg.StageCode,
		arg.Txid,
		arg.UnsignedTx,
		arg.ConnectorAddress,
		arg.DustAmount,
		arg.Version,
		arg.Swept,
	)
	return err
}

const upsertTransaction = `-- name: UpsertTransaction :exec
INSERT INTO tx (
    tx, round_id, type, position, txid, tree_level, parent_txid, is_leaf
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    tx = EXCLUDED.tx,
    round_id = EXCLUDED.round_id,
    type = EXCLUDED.type,
    position = EXCLUDED.position,
    txid = EXCLUDED.txid,
    tree_level = EXCLUDED.tree_level,
    parent_txid = EXCLUDED.parent_txid,
    is_leaf = EXCLUDED.is_leaf
`

type UpsertTransactionParams struct {
	Tx         string
	RoundID    string
	Type       string
	Position   int64
	Txid       sql.NullString
	TreeLevel  sql.NullInt64
	ParentTxid sql.NullString
	IsLeaf     sql.NullBool
}

func (q *Queries) UpsertTransaction(ctx context.Context, arg UpsertTransactionParams) error {
	_, err := q.db.ExecContext(ctx, upsertTransaction,
		arg.Tx,
		arg.RoundID,
		arg.Type,
		arg.Position,
		arg.Txid,
		arg.TreeLevel,
		arg.ParentTxid,
		arg.IsLeaf,
	)
	return err
}

const upsertTxRequest = `-- name: UpsertTxRequest :exec
INSERT INTO tx_request (id, round_id) VALUES (?, ?)
ON CONFLICT(id) DO UPDATE SET round_id = EXCLUDED.round_id
`

type UpsertTxRequestParams struct {
	ID      string
	RoundID string
}

func (q *Queries) UpsertTxRequest(ctx context.Context, arg UpsertTxRequestParams) error {
	_, err := q.db.ExecContext(ctx, upsertTxRequest, arg.ID, arg.RoundID)
	return err
}

const upsertVtxo = `-- name: UpsertVtxo :exec
INSERT INTO vtxo (txid, vout, pubkey, amount, round_tx, spent_by, spent, redeemed, swept, expire_at, created_at, redeem_tx)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT(txid, vout) DO UPDATE SET
    pubkey = EXCLUDED.pubkey,
    amount = EXCLUDED.amount,
    round_tx = EXCLUDED.round_tx,
    spent_by = EXCLUDED.spent_by,
    spent = EXCLUDED.spent,
    redeemed = EXCLUDED.redeemed,
    swept = EXCLUDED.swept,
    expire_at = EXCLUDED.expire_at,
    created_at = EXCLUDED.created_at,
    redeem_tx = EXCLUDED.redeem_tx
`

type UpsertVtxoParams struct {
	Txid      string
	Vout      int64
	Pubkey    string
	Amount    int64
	RoundTx   string
	SpentBy   string
	Spent     bool
	Redeemed  bool
	Swept     bool
	ExpireAt  int64
	CreatedAt int64
	RedeemTx  sql.NullString
}

func (q *Queries) UpsertVtxo(ctx context.Context, arg UpsertVtxoParams) error {
	_, err := q.db.ExecContext(ctx, upsertVtxo,
		arg.Txid,
		arg.Vout,
		arg.Pubkey,
		arg.Amount,
		arg.RoundTx,
		arg.SpentBy,
		arg.Spent,
		arg.Redeemed,
		arg.Swept,
		arg.ExpireAt,
		arg.CreatedAt,
		arg.RedeemTx,
	)
	return err
}
