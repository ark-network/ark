// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const containsNote = `-- name: ContainsNote :one
SELECT EXISTS(SELECT 1 FROM note WHERE id = ?)
`

func (q *Queries) ContainsNote(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, containsNote, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteEntity = `-- name: DeleteEntity :exec
DELETE FROM entity WHERE id = ?
`

func (q *Queries) DeleteEntity(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEntity, id)
	return err
}

const deleteEntityVtxo = `-- name: DeleteEntityVtxo :exec
DELETE FROM entity_vtxo WHERE entity_id = ?
`

func (q *Queries) DeleteEntityVtxo(ctx context.Context, entityID int64) error {
	_, err := q.db.ExecContext(ctx, deleteEntityVtxo, entityID)
	return err
}

const getExistingRounds = `-- name: GetExistingRounds :many
SELECT txid FROM round WHERE txid IN (/*SLICE:txids*/?)
`

func (q *Queries) GetExistingRounds(ctx context.Context, txids []string) ([]string, error) {
	query := getExistingRounds
	var queryParams []interface{}
	if len(txids) > 0 {
		for _, v := range txids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:txids*/?", strings.Repeat(",?", len(txids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:txids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMarketHour = `-- name: GetLatestMarketHour :one
SELECT id, start_time, end_time, period, round_interval, updated_at FROM market_hour ORDER BY updated_at DESC LIMIT 1
`

func (q *Queries) GetLatestMarketHour(ctx context.Context) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, getLatestMarketHour)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoundConnectorTreeTxs = `-- name: GetRoundConnectorTreeTxs :many
SELECT tx.txid, tx.tx, tx.round_id, tx.type, tx.position, tx.tree_level, tx.parent_txid, tx.is_leaf FROM round
LEFT OUTER JOIN tx ON round.id=tx.round_id
WHERE round.txid = ? AND tx.type = 'connector'
`

type GetRoundConnectorTreeTxsRow struct {
	Txid       sql.NullString
	Tx         sql.NullString
	RoundID    sql.NullString
	Type       sql.NullString
	Position   sql.NullInt64
	TreeLevel  sql.NullInt64
	ParentTxid sql.NullString
	IsLeaf     sql.NullBool
}

func (q *Queries) GetRoundConnectorTreeTxs(ctx context.Context, txid string) ([]GetRoundConnectorTreeTxsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoundConnectorTreeTxs, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoundConnectorTreeTxsRow
	for rows.Next() {
		var i GetRoundConnectorTreeTxsRow
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.TreeLevel,
			&i.ParentTxid,
			&i.IsLeaf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoundForfeitTxs = `-- name: GetRoundForfeitTxs :many
SELECT tx.txid, tx.tx, tx.round_id, tx.type, tx.position, tx.tree_level, tx.parent_txid, tx.is_leaf FROM round
LEFT OUTER JOIN tx ON round.id=tx.round_id
WHERE round.txid = ? AND tx.type = 'forfeit'
`

type GetRoundForfeitTxsRow struct {
	Txid       sql.NullString
	Tx         sql.NullString
	RoundID    sql.NullString
	Type       sql.NullString
	Position   sql.NullInt64
	TreeLevel  sql.NullInt64
	ParentTxid sql.NullString
	IsLeaf     sql.NullBool
}

func (q *Queries) GetRoundForfeitTxs(ctx context.Context, txid string) ([]GetRoundForfeitTxsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoundForfeitTxs, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoundForfeitTxsRow
	for rows.Next() {
		var i GetRoundForfeitTxsRow
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.TreeLevel,
			&i.ParentTxid,
			&i.IsLeaf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoundStats = `-- name: GetRoundStats :one
SELECT
    r.swept,
    r.starting_timestamp,
    r.ending_timestamp,
    (
        SELECT COALESCE(SUM(amount), 0)
        FROM (
            SELECT DISTINCT v2.txid, v2.vout, v2.pubkey, v2.amount, v2.round_tx, v2.spent_by, v2.spent, v2.redeemed, v2.swept, v2.expire_at, v2.created_at, v2.request_id, v2.redeem_tx
            FROM vtxo v2
                    JOIN tx_request req2 ON req2.id = v2.request_id
            WHERE req2.round_id = r.id
        ) as tx_req_inputs_amount
    ) AS total_forfeit_amount,
    (
        SELECT COALESCE(COUNT(v3.txid), 0)
        FROM vtxo v3
                 JOIN tx_request req3 ON req3.id = v3.request_id
        WHERE req3.round_id = r.id
    ) AS total_input_vtxos,
    (
        SELECT COALESCE(SUM(amount), 0)
        FROM (
            SELECT DISTINCT rr.request_id, rr.pubkey, rr.onchain_address, rr.amount
            FROM receiver rr
                JOIN tx_request req4 ON req4.id = rr.request_id
            WHERE req4.round_id = r.id
            AND (rr.onchain_address = '' OR rr.onchain_address IS NULL)
        ) AS tx_req_outputs_amount
    ) AS total_batch_amount,
    (
        SELECT COUNT(*)
        FROM tx t
        WHERE t.round_id = r.id
          AND t.type = 'tree'
          AND t.is_leaf = 1
    ) AS total_output_vtxos,
    (
        SELECT MAX(v.expire_at)
        FROM vtxo v
        WHERE v.round_tx = r.txid
    ) AS expires_at
FROM round r
WHERE r.txid = ?
`

type GetRoundStatsRow struct {
	Swept              bool
	StartingTimestamp  int64
	EndingTimestamp    int64
	TotalForfeitAmount interface{}
	TotalInputVtxos    interface{}
	TotalBatchAmount   interface{}
	TotalOutputVtxos   int64
	ExpiresAt          interface{}
}

func (q *Queries) GetRoundStats(ctx context.Context, txid string) (GetRoundStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getRoundStats, txid)
	var i GetRoundStatsRow
	err := row.Scan(
		&i.Swept,
		&i.StartingTimestamp,
		&i.EndingTimestamp,
		&i.TotalForfeitAmount,
		&i.TotalInputVtxos,
		&i.TotalBatchAmount,
		&i.TotalOutputVtxos,
		&i.ExpiresAt,
	)
	return i, err
}

const getSpendableVtxosWithPubKey = `-- name: GetSpendableVtxosWithPubKey :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE vtxo.pubkey = ? AND vtxo.spent = false AND vtxo.swept = false
`

func (q *Queries) GetSpendableVtxosWithPubKey(ctx context.Context, pubkey string) ([]Vtxo, error) {
	rows, err := q.db.QueryContext(ctx, getSpendableVtxosWithPubKey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vtxo
	for rows.Next() {
		var i Vtxo
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Pubkey,
			&i.Amount,
			&i.RoundTx,
			&i.SpentBy,
			&i.Spent,
			&i.Redeemed,
			&i.Swept,
			&i.ExpireAt,
			&i.CreatedAt,
			&i.RequestID,
			&i.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTxsByTxid = `-- name: GetTxsByTxid :many
SELECT
    tx.txid,
    tx.tx AS data
FROM tx
WHERE tx.txid IN (/*SLICE:ids1*/?)
UNION
SELECT
    vtxo.txid,
    vtxo.redeem_tx AS data
FROM vtxo
WHERE vtxo.txid IN (/*SLICE:ids2*/?) AND vtxo.redeem_tx IS NOT ''
`

type GetTxsByTxidParams struct {
	Ids1 []string
	Ids2 []string
}

type GetTxsByTxidRow struct {
	Txid string
	Data string
}

func (q *Queries) GetTxsByTxid(ctx context.Context, arg GetTxsByTxidParams) ([]GetTxsByTxidRow, error) {
	query := getTxsByTxid
	var queryParams []interface{}
	if len(arg.Ids1) > 0 {
		for _, v := range arg.Ids1 {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids1*/?", strings.Repeat(",?", len(arg.Ids1))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids1*/?", "NULL", 1)
	}
	if len(arg.Ids2) > 0 {
		for _, v := range arg.Ids2 {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids2*/?", strings.Repeat(",?", len(arg.Ids2))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids2*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTxsByTxidRow
	for rows.Next() {
		var i GetTxsByTxidRow
		if err := rows.Scan(&i.Txid, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMarketHour = `-- name: InsertMarketHour :one
INSERT INTO market_hour (
    start_time,
    end_time,
    period,
    round_interval,
    updated_at
) VALUES (?, ?, ?, ?, ?)
RETURNING id, start_time, end_time, period, round_interval, updated_at
`

type InsertMarketHourParams struct {
	StartTime     int64
	EndTime       int64
	Period        int64
	RoundInterval int64
	UpdatedAt     int64
}

func (q *Queries) InsertMarketHour(ctx context.Context, arg InsertMarketHourParams) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, insertMarketHour,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.RoundInterval,
		arg.UpdatedAt,
	)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const insertNote = `-- name: InsertNote :exec
INSERT INTO note (id) VALUES (?)
`

func (q *Queries) InsertNote(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, insertNote, id)
	return err
}

const markVtxoAsRedeemed = `-- name: MarkVtxoAsRedeemed :exec
UPDATE vtxo SET redeemed = true WHERE txid = ? AND vout = ?
`

type MarkVtxoAsRedeemedParams struct {
	Txid string
	Vout int64
}

func (q *Queries) MarkVtxoAsRedeemed(ctx context.Context, arg MarkVtxoAsRedeemedParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsRedeemed, arg.Txid, arg.Vout)
	return err
}

const markVtxoAsSpent = `-- name: MarkVtxoAsSpent :exec
UPDATE vtxo SET spent = true, spent_by = ? WHERE txid = ? AND vout = ?
`

type MarkVtxoAsSpentParams struct {
	SpentBy string
	Txid    string
	Vout    int64
}

func (q *Queries) MarkVtxoAsSpent(ctx context.Context, arg MarkVtxoAsSpentParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsSpent, arg.SpentBy, arg.Txid, arg.Vout)
	return err
}

const markVtxoAsSwept = `-- name: MarkVtxoAsSwept :exec
UPDATE vtxo SET swept = true WHERE txid = ? AND vout = ?
`

type MarkVtxoAsSweptParams struct {
	Txid string
	Vout int64
}

func (q *Queries) MarkVtxoAsSwept(ctx context.Context, arg MarkVtxoAsSweptParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsSwept, arg.Txid, arg.Vout)
	return err
}

const selectAllVtxos = `-- name: SelectAllVtxos :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
`

type SelectAllVtxosRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectAllVtxos(ctx context.Context) ([]SelectAllVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectAllVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllVtxosRow
	for rows.Next() {
		var i SelectAllVtxosRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectExpiredRoundsTxid = `-- name: SelectExpiredRoundsTxid :many
SELECT round.txid FROM round
WHERE round.swept = false AND round.ended = true AND round.failed = false
`

func (q *Queries) SelectExpiredRoundsTxid(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectExpiredRoundsTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectLeafVtxosByRoundTxid = `-- name: SelectLeafVtxosByRoundTxid :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE round_tx = ? AND (redeem_tx IS NULL or redeem_tx = '')
`

type SelectLeafVtxosByRoundTxidRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectLeafVtxosByRoundTxid(ctx context.Context, roundTx string) ([]SelectLeafVtxosByRoundTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectLeafVtxosByRoundTxid, roundTx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectLeafVtxosByRoundTxidRow
	for rows.Next() {
		var i SelectLeafVtxosByRoundTxidRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotRedeemedVtxos = `-- name: SelectNotRedeemedVtxos :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE redeemed = false
`

type SelectNotRedeemedVtxosRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectNotRedeemedVtxos(ctx context.Context) ([]SelectNotRedeemedVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotRedeemedVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotRedeemedVtxosRow
	for rows.Next() {
		var i SelectNotRedeemedVtxosRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotRedeemedVtxosWithPubkey = `-- name: SelectNotRedeemedVtxosWithPubkey :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE redeemed = false AND pubkey = ?
`

type SelectNotRedeemedVtxosWithPubkeyRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectNotRedeemedVtxosWithPubkey(ctx context.Context, pubkey string) ([]SelectNotRedeemedVtxosWithPubkeyRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotRedeemedVtxosWithPubkey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotRedeemedVtxosWithPubkeyRow
	for rows.Next() {
		var i SelectNotRedeemedVtxosWithPubkeyRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIds = `-- name: SelectRoundIds :many
SELECT id FROM round
`

func (q *Queries) SelectRoundIds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsInRange = `-- name: SelectRoundIdsInRange :many
SELECT id FROM round WHERE starting_timestamp > ? AND starting_timestamp < ?
`

type SelectRoundIdsInRangeParams struct {
	StartingTimestamp   int64
	StartingTimestamp_2 int64
}

func (q *Queries) SelectRoundIdsInRange(ctx context.Context, arg SelectRoundIdsInRangeParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsInRange, arg.StartingTimestamp, arg.StartingTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithRoundId = `-- name: SelectRoundWithRoundId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.txid, round.unsigned_tx, round.connector_address, round.dust_amount, round.version, round.swept,
       round_request_vw.id, round_request_vw.round_id,
       round_tx_vw.txid, round_tx_vw.tx, round_tx_vw.round_id, round_tx_vw.type, round_tx_vw.position, round_tx_vw.tree_level, round_tx_vw.parent_txid, round_tx_vw.is_leaf,
       request_receiver_vw.request_id, request_receiver_vw.pubkey, request_receiver_vw.onchain_address, request_receiver_vw.amount,
       request_vtxo_vw.txid, request_vtxo_vw.vout, request_vtxo_vw.pubkey, request_vtxo_vw.amount, request_vtxo_vw.round_tx, request_vtxo_vw.spent_by, request_vtxo_vw.spent, request_vtxo_vw.redeemed, request_vtxo_vw.swept, request_vtxo_vw.expire_at, request_vtxo_vw.created_at, request_vtxo_vw.request_id, request_vtxo_vw.redeem_tx
FROM round
         LEFT OUTER JOIN round_request_vw ON round.id=round_request_vw.round_id
         LEFT OUTER JOIN round_tx_vw ON round.id=round_tx_vw.round_id
         LEFT OUTER JOIN request_receiver_vw ON round_request_vw.id=request_receiver_vw.request_id
         LEFT OUTER JOIN request_vtxo_vw ON round_request_vw.id=request_vtxo_vw.request_id
WHERE round.id = ?
`

type SelectRoundWithRoundIdRow struct {
	Round             Round
	RoundRequestVw    RoundRequestVw
	RoundTxVw         RoundTxVw
	RequestReceiverVw RequestReceiverVw
	RequestVtxoVw     RequestVtxoVw
}

func (q *Queries) SelectRoundWithRoundId(ctx context.Context, id string) ([]SelectRoundWithRoundIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithRoundId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithRoundIdRow
	for rows.Next() {
		var i SelectRoundWithRoundIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.Txid,
			&i.Round.UnsignedTx,
			&i.Round.ConnectorAddress,
			&i.Round.DustAmount,
			&i.Round.Version,
			&i.Round.Swept,
			&i.RoundRequestVw.ID,
			&i.RoundRequestVw.RoundID,
			&i.RoundTxVw.Txid,
			&i.RoundTxVw.Tx,
			&i.RoundTxVw.RoundID,
			&i.RoundTxVw.Type,
			&i.RoundTxVw.Position,
			&i.RoundTxVw.TreeLevel,
			&i.RoundTxVw.ParentTxid,
			&i.RoundTxVw.IsLeaf,
			&i.RequestReceiverVw.RequestID,
			&i.RequestReceiverVw.Pubkey,
			&i.RequestReceiverVw.OnchainAddress,
			&i.RequestReceiverVw.Amount,
			&i.RequestVtxoVw.Txid,
			&i.RequestVtxoVw.Vout,
			&i.RequestVtxoVw.Pubkey,
			&i.RequestVtxoVw.Amount,
			&i.RequestVtxoVw.RoundTx,
			&i.RequestVtxoVw.SpentBy,
			&i.RequestVtxoVw.Spent,
			&i.RequestVtxoVw.Redeemed,
			&i.RequestVtxoVw.Swept,
			&i.RequestVtxoVw.ExpireAt,
			&i.RequestVtxoVw.CreatedAt,
			&i.RequestVtxoVw.RequestID,
			&i.RequestVtxoVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithRoundTxId = `-- name: SelectRoundWithRoundTxId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.txid, round.unsigned_tx, round.connector_address, round.dust_amount, round.version, round.swept,
       round_request_vw.id, round_request_vw.round_id,
       round_tx_vw.txid, round_tx_vw.tx, round_tx_vw.round_id, round_tx_vw.type, round_tx_vw.position, round_tx_vw.tree_level, round_tx_vw.parent_txid, round_tx_vw.is_leaf,
       request_receiver_vw.request_id, request_receiver_vw.pubkey, request_receiver_vw.onchain_address, request_receiver_vw.amount,
       request_vtxo_vw.txid, request_vtxo_vw.vout, request_vtxo_vw.pubkey, request_vtxo_vw.amount, request_vtxo_vw.round_tx, request_vtxo_vw.spent_by, request_vtxo_vw.spent, request_vtxo_vw.redeemed, request_vtxo_vw.swept, request_vtxo_vw.expire_at, request_vtxo_vw.created_at, request_vtxo_vw.request_id, request_vtxo_vw.redeem_tx
FROM round
         LEFT OUTER JOIN round_request_vw ON round.id=round_request_vw.round_id
         LEFT OUTER JOIN round_tx_vw ON round.id=round_tx_vw.round_id
         LEFT OUTER JOIN request_receiver_vw ON round_request_vw.id=request_receiver_vw.request_id
         LEFT OUTER JOIN request_vtxo_vw ON round_request_vw.id=request_vtxo_vw.request_id
WHERE round.txid = ?
`

type SelectRoundWithRoundTxIdRow struct {
	Round             Round
	RoundRequestVw    RoundRequestVw
	RoundTxVw         RoundTxVw
	RequestReceiverVw RequestReceiverVw
	RequestVtxoVw     RequestVtxoVw
}

func (q *Queries) SelectRoundWithRoundTxId(ctx context.Context, txid string) ([]SelectRoundWithRoundTxIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithRoundTxId, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithRoundTxIdRow
	for rows.Next() {
		var i SelectRoundWithRoundTxIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.Txid,
			&i.Round.UnsignedTx,
			&i.Round.ConnectorAddress,
			&i.Round.DustAmount,
			&i.Round.Version,
			&i.Round.Swept,
			&i.RoundRequestVw.ID,
			&i.RoundRequestVw.RoundID,
			&i.RoundTxVw.Txid,
			&i.RoundTxVw.Tx,
			&i.RoundTxVw.RoundID,
			&i.RoundTxVw.Type,
			&i.RoundTxVw.Position,
			&i.RoundTxVw.TreeLevel,
			&i.RoundTxVw.ParentTxid,
			&i.RoundTxVw.IsLeaf,
			&i.RequestReceiverVw.RequestID,
			&i.RequestReceiverVw.Pubkey,
			&i.RequestReceiverVw.OnchainAddress,
			&i.RequestReceiverVw.Amount,
			&i.RequestVtxoVw.Txid,
			&i.RequestVtxoVw.Vout,
			&i.RequestVtxoVw.Pubkey,
			&i.RequestVtxoVw.Amount,
			&i.RequestVtxoVw.RoundTx,
			&i.RequestVtxoVw.SpentBy,
			&i.RequestVtxoVw.Spent,
			&i.RequestVtxoVw.Redeemed,
			&i.RequestVtxoVw.Swept,
			&i.RequestVtxoVw.ExpireAt,
			&i.RequestVtxoVw.CreatedAt,
			&i.RequestVtxoVw.RequestID,
			&i.RequestVtxoVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableVtxos = `-- name: SelectSweepableVtxos :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE redeemed = false AND swept = false
`

type SelectSweepableVtxosRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectSweepableVtxos(ctx context.Context) ([]SelectSweepableVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectSweepableVtxosRow
	for rows.Next() {
		var i SelectSweepableVtxosRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweptRoundsConnectorAddress = `-- name: SelectSweptRoundsConnectorAddress :many
SELECT round.connector_address FROM round
WHERE round.swept = true AND round.failed = false AND round.ended = true AND round.connector_address <> ''
`

func (q *Queries) SelectSweptRoundsConnectorAddress(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweptRoundsConnectorAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var connector_address string
		if err := rows.Scan(&connector_address); err != nil {
			return nil, err
		}
		items = append(items, connector_address)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTreeTxsWithRoundTxid = `-- name: SelectTreeTxsWithRoundTxid :many
SELECT tx.txid, tx.tx, tx.round_id, tx.type, tx.position, tx.tree_level, tx.parent_txid, tx.is_leaf FROM round
LEFT OUTER JOIN tx ON round.id=tx.round_id
WHERE round.txid = ? AND tx.type = 'tree'
`

type SelectTreeTxsWithRoundTxidRow struct {
	Txid       sql.NullString
	Tx         sql.NullString
	RoundID    sql.NullString
	Type       sql.NullString
	Position   sql.NullInt64
	TreeLevel  sql.NullInt64
	ParentTxid sql.NullString
	IsLeaf     sql.NullBool
}

func (q *Queries) SelectTreeTxsWithRoundTxid(ctx context.Context, txid string) ([]SelectTreeTxsWithRoundTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectTreeTxsWithRoundTxid, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectTreeTxsWithRoundTxidRow
	for rows.Next() {
		var i SelectTreeTxsWithRoundTxidRow
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.TreeLevel,
			&i.ParentTxid,
			&i.IsLeaf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxoByOutpoint = `-- name: SelectVtxoByOutpoint :one
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE txid = ? AND vout = ?
`

type SelectVtxoByOutpointParams struct {
	Txid string
	Vout int64
}

type SelectVtxoByOutpointRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectVtxoByOutpoint(ctx context.Context, arg SelectVtxoByOutpointParams) (SelectVtxoByOutpointRow, error) {
	row := q.db.QueryRowContext(ctx, selectVtxoByOutpoint, arg.Txid, arg.Vout)
	var i SelectVtxoByOutpointRow
	err := row.Scan(
		&i.Vtxo.Txid,
		&i.Vtxo.Vout,
		&i.Vtxo.Pubkey,
		&i.Vtxo.Amount,
		&i.Vtxo.RoundTx,
		&i.Vtxo.SpentBy,
		&i.Vtxo.Spent,
		&i.Vtxo.Redeemed,
		&i.Vtxo.Swept,
		&i.Vtxo.ExpireAt,
		&i.Vtxo.CreatedAt,
		&i.Vtxo.RequestID,
		&i.Vtxo.RedeemTx,
	)
	return i, err
}

const selectVtxosByRoundTxid = `-- name: SelectVtxosByRoundTxid :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE round_tx = ?
`

type SelectVtxosByRoundTxidRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectVtxosByRoundTxid(ctx context.Context, roundTx string) ([]SelectVtxosByRoundTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosByRoundTxid, roundTx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosByRoundTxidRow
	for rows.Next() {
		var i SelectVtxosByRoundTxidRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosWithPubkey = `-- name: SelectVtxosWithPubkey :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo WHERE pubkey = ?
`

type SelectVtxosWithPubkeyRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectVtxosWithPubkey(ctx context.Context, pubkey string) ([]SelectVtxosWithPubkeyRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosWithPubkey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosWithPubkeyRow
	for rows.Next() {
		var i SelectVtxosWithPubkeyRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMarketHour = `-- name: UpdateMarketHour :one
UPDATE market_hour
SET start_time = ?,
    end_time = ?,
    period = ?,
    round_interval = ?,
    updated_at = ?
WHERE id = ?
RETURNING id, start_time, end_time, period, round_interval, updated_at
`

type UpdateMarketHourParams struct {
	StartTime     int64
	EndTime       int64
	Period        int64
	RoundInterval int64
	UpdatedAt     int64
	ID            int64
}

func (q *Queries) UpdateMarketHour(ctx context.Context, arg UpdateMarketHourParams) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, updateMarketHour,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.RoundInterval,
		arg.UpdatedAt,
		arg.ID,
	)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVtxoExpireAt = `-- name: UpdateVtxoExpireAt :exec
UPDATE vtxo SET expire_at = ? WHERE txid = ? AND vout = ?
`

type UpdateVtxoExpireAtParams struct {
	ExpireAt int64
	Txid     string
	Vout     int64
}

func (q *Queries) UpdateVtxoExpireAt(ctx context.Context, arg UpdateVtxoExpireAtParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoExpireAt, arg.ExpireAt, arg.Txid, arg.Vout)
	return err
}

const updateVtxoRequestId = `-- name: UpdateVtxoRequestId :exec
UPDATE vtxo SET request_id = ? WHERE txid = ? AND vout = ?
`

type UpdateVtxoRequestIdParams struct {
	RequestID sql.NullString
	Txid      string
	Vout      int64
}

func (q *Queries) UpdateVtxoRequestId(ctx context.Context, arg UpdateVtxoRequestIdParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoRequestId, arg.RequestID, arg.Txid, arg.Vout)
	return err
}

const upsertReceiver = `-- name: UpsertReceiver :exec
INSERT INTO receiver (request_id, pubkey, onchain_address, amount) VALUES (?, ?, ?, ?)
ON CONFLICT(request_id, pubkey, onchain_address) DO UPDATE SET
    amount = EXCLUDED.amount,
    pubkey = EXCLUDED.pubkey,
    onchain_address = EXCLUDED.onchain_address
`

type UpsertReceiverParams struct {
	RequestID      string
	Pubkey         sql.NullString
	OnchainAddress sql.NullString
	Amount         int64
}

func (q *Queries) UpsertReceiver(ctx context.Context, arg UpsertReceiverParams) error {
	_, err := q.db.ExecContext(ctx, upsertReceiver,
		arg.RequestID,
		arg.Pubkey,
		arg.OnchainAddress,
		arg.Amount,
	)
	return err
}

const upsertRound = `-- name: UpsertRound :exec
INSERT INTO round (
    id,
    starting_timestamp,
    ending_timestamp,
    ended, failed,
    stage_code,
    txid,
    unsigned_tx,
    connector_address,
    dust_amount,
    version,
    swept
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    ended = EXCLUDED.ended,
    failed = EXCLUDED.failed,
    stage_code = EXCLUDED.stage_code,
    txid = EXCLUDED.txid,
    unsigned_tx = EXCLUDED.unsigned_tx,
    connector_address = EXCLUDED.connector_address,
    dust_amount = EXCLUDED.dust_amount,
    version = EXCLUDED.version,
    swept = EXCLUDED.swept
`

type UpsertRoundParams struct {
	ID                string
	StartingTimestamp int64
	EndingTimestamp   int64
	Ended             bool
	Failed            bool
	StageCode         int64
	Txid              string
	UnsignedTx        string
	ConnectorAddress  string
	DustAmount        int64
	Version           int64
	Swept             bool
}

func (q *Queries) UpsertRound(ctx context.Context, arg UpsertRoundParams) error {
	_, err := q.db.ExecContext(ctx, upsertRound,
		arg.ID,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.Ended,
		arg.Failed,
		arg.StageCode,
		arg.Txid,
		arg.UnsignedTx,
		arg.ConnectorAddress,
		arg.DustAmount,
		arg.Version,
		arg.Swept,
	)
	return err
}

const upsertTransaction = `-- name: UpsertTransaction :exec
INSERT INTO tx (
    tx, round_id, type, position, txid, tree_level, parent_txid, is_leaf
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    round_id = EXCLUDED.round_id,
    type = EXCLUDED.type,
    position = EXCLUDED.position,
    txid = EXCLUDED.txid,
    tree_level = EXCLUDED.tree_level,
    parent_txid = EXCLUDED.parent_txid,
    is_leaf = EXCLUDED.is_leaf
`

type UpsertTransactionParams struct {
	Tx         string
	RoundID    string
	Type       string
	Position   int64
	Txid       string
	TreeLevel  sql.NullInt64
	ParentTxid sql.NullString
	IsLeaf     sql.NullBool
}

func (q *Queries) UpsertTransaction(ctx context.Context, arg UpsertTransactionParams) error {
	_, err := q.db.ExecContext(ctx, upsertTransaction,
		arg.Tx,
		arg.RoundID,
		arg.Type,
		arg.Position,
		arg.Txid,
		arg.TreeLevel,
		arg.ParentTxid,
		arg.IsLeaf,
	)
	return err
}

const upsertTxRequest = `-- name: UpsertTxRequest :exec
INSERT INTO tx_request (id, round_id) VALUES (?, ?)
ON CONFLICT(id) DO UPDATE SET round_id = EXCLUDED.round_id
`

type UpsertTxRequestParams struct {
	ID      string
	RoundID string
}

func (q *Queries) UpsertTxRequest(ctx context.Context, arg UpsertTxRequestParams) error {
	_, err := q.db.ExecContext(ctx, upsertTxRequest, arg.ID, arg.RoundID)
	return err
}

const upsertVtxo = `-- name: UpsertVtxo :exec
INSERT INTO vtxo (txid, vout, pubkey, amount, round_tx, spent_by, spent, redeemed, swept, expire_at, created_at, redeem_tx)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT(txid, vout) DO UPDATE SET
    pubkey = EXCLUDED.pubkey,
    amount = EXCLUDED.amount,
    round_tx = EXCLUDED.round_tx,
    spent_by = EXCLUDED.spent_by,
    spent = EXCLUDED.spent,
    redeemed = EXCLUDED.redeemed,
    swept = EXCLUDED.swept,
    expire_at = EXCLUDED.expire_at,
    created_at = EXCLUDED.created_at,
    redeem_tx = EXCLUDED.redeem_tx
`

type UpsertVtxoParams struct {
	Txid      string
	Vout      int64
	Pubkey    string
	Amount    int64
	RoundTx   string
	SpentBy   string
	Spent     bool
	Redeemed  bool
	Swept     bool
	ExpireAt  int64
	CreatedAt int64
	RedeemTx  sql.NullString
}

func (q *Queries) UpsertVtxo(ctx context.Context, arg UpsertVtxoParams) error {
	_, err := q.db.ExecContext(ctx, upsertVtxo,
		arg.Txid,
		arg.Vout,
		arg.Pubkey,
		arg.Amount,
		arg.RoundTx,
		arg.SpentBy,
		arg.Spent,
		arg.Redeemed,
		arg.Swept,
		arg.ExpireAt,
		arg.CreatedAt,
		arg.RedeemTx,
	)
	return err
}
