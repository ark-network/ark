// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const getExistingRounds = `-- name: GetExistingRounds :many
SELECT txid FROM round WHERE txid IN (/*SLICE:txids*/?)
`

func (q *Queries) GetExistingRounds(ctx context.Context, txids []string) ([]string, error) {
	query := getExistingRounds
	var queryParams []interface{}
	if len(txids) > 0 {
		for _, v := range txids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:txids*/?", strings.Repeat(",?", len(txids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:txids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMarketHour = `-- name: GetLatestMarketHour :one
SELECT id, start_time, end_time, period, round_interval, updated_at FROM market_hour ORDER BY updated_at DESC LIMIT 1
`

func (q *Queries) GetLatestMarketHour(ctx context.Context) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, getLatestMarketHour)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoundConnectorTreeTxs = `-- name: GetRoundConnectorTreeTxs :many
SELECT tx.txid, tx.tx, tx.round_id, tx.type, tx.position, tx.children FROM round
LEFT OUTER JOIN tx ON round.id=tx.round_id
WHERE round.txid = ? AND tx.type = 'connector'
`

type GetRoundConnectorTreeTxsRow struct {
	Txid     sql.NullString
	Tx       sql.NullString
	RoundID  sql.NullString
	Type     sql.NullString
	Position sql.NullInt64
	Children sql.NullString
}

func (q *Queries) GetRoundConnectorTreeTxs(ctx context.Context, txid string) ([]GetRoundConnectorTreeTxsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoundConnectorTreeTxs, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoundConnectorTreeTxsRow
	for rows.Next() {
		var i GetRoundConnectorTreeTxsRow
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoundForfeitTxs = `-- name: GetRoundForfeitTxs :many
SELECT tx.txid, tx.tx, tx.round_id, tx.type, tx.position, tx.children FROM round
LEFT OUTER JOIN tx ON round.id=tx.round_id
WHERE round.txid = ? AND tx.type = 'forfeit'
`

type GetRoundForfeitTxsRow struct {
	Txid     sql.NullString
	Tx       sql.NullString
	RoundID  sql.NullString
	Type     sql.NullString
	Position sql.NullInt64
	Children sql.NullString
}

func (q *Queries) GetRoundForfeitTxs(ctx context.Context, txid string) ([]GetRoundForfeitTxsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoundForfeitTxs, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoundForfeitTxsRow
	for rows.Next() {
		var i GetRoundForfeitTxsRow
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoundStats = `-- name: GetRoundStats :one
SELECT
    r.swept,
    r.starting_timestamp,
    r.ending_timestamp,
    (
        SELECT COALESCE(SUM(amount), 0)
        FROM (
            SELECT DISTINCT v2.txid, v2.vout, v2.pubkey, v2.amount, v2.round_tx, v2.spent_by, v2.spent, v2.redeemed, v2.swept, v2.expire_at, v2.created_at, v2.request_id, v2.redeem_tx
            FROM vtxo v2
                    JOIN tx_request req2 ON req2.id = v2.request_id
            WHERE req2.round_id = r.id
        ) as tx_req_inputs_amount
    ) AS total_forfeit_amount,
    (
        SELECT COALESCE(COUNT(v3.txid), 0)
        FROM vtxo v3
                 JOIN tx_request req3 ON req3.id = v3.request_id
        WHERE req3.round_id = r.id
    ) AS total_input_vtxos,
    (
        SELECT COALESCE(SUM(amount), 0)
        FROM (
            SELECT DISTINCT rr.request_id, rr.pubkey, rr.onchain_address, rr.amount
            FROM receiver rr
                JOIN tx_request req4 ON req4.id = rr.request_id
            WHERE req4.round_id = r.id
            AND (rr.onchain_address = '' OR rr.onchain_address IS NULL)
        ) AS tx_req_outputs_amount
    ) AS total_batch_amount,
    (
        SELECT COUNT(*)
        FROM tx t
        WHERE t.round_id = r.id
          AND t.type = 'tree'
          AND TRIM(COALESCE(t.children, '')) = ''
    ) AS total_output_vtxos,
    (
        SELECT MAX(v.expire_at)
        FROM vtxo v
        WHERE v.round_tx = r.txid
    ) AS expires_at
FROM round r
WHERE r.txid = ?
`

type GetRoundStatsRow struct {
	Swept              bool
	StartingTimestamp  int64
	EndingTimestamp    int64
	TotalForfeitAmount interface{}
	TotalInputVtxos    interface{}
	TotalBatchAmount   interface{}
	TotalOutputVtxos   int64
	ExpiresAt          interface{}
}

func (q *Queries) GetRoundStats(ctx context.Context, txid string) (GetRoundStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getRoundStats, txid)
	var i GetRoundStatsRow
	err := row.Scan(
		&i.Swept,
		&i.StartingTimestamp,
		&i.EndingTimestamp,
		&i.TotalForfeitAmount,
		&i.TotalInputVtxos,
		&i.TotalBatchAmount,
		&i.TotalOutputVtxos,
		&i.ExpiresAt,
	)
	return i, err
}

const getSpendableVtxosWithPubKey = `-- name: GetSpendableVtxosWithPubKey :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE vtxo.pubkey = ? AND vtxo.spent = false AND vtxo.swept = false
`

func (q *Queries) GetSpendableVtxosWithPubKey(ctx context.Context, pubkey string) ([]Vtxo, error) {
	rows, err := q.db.QueryContext(ctx, getSpendableVtxosWithPubKey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vtxo
	for rows.Next() {
		var i Vtxo
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Pubkey,
			&i.Amount,
			&i.RoundTx,
			&i.SpentBy,
			&i.Spent,
			&i.Redeemed,
			&i.Swept,
			&i.ExpireAt,
			&i.CreatedAt,
			&i.RequestID,
			&i.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTxsByTxid = `-- name: GetTxsByTxid :many
SELECT
    tx.txid,
    tx.tx AS data
FROM tx
WHERE tx.txid IN (/*SLICE:ids1*/?)
UNION
SELECT
    vtxo.txid,
    vtxo.redeem_tx AS data
FROM vtxo
WHERE vtxo.txid IN (/*SLICE:ids2*/?) AND vtxo.redeem_tx IS NOT ''
`

type GetTxsByTxidParams struct {
	Ids1 []string
	Ids2 []string
}

type GetTxsByTxidRow struct {
	Txid string
	Data string
}

func (q *Queries) GetTxsByTxid(ctx context.Context, arg GetTxsByTxidParams) ([]GetTxsByTxidRow, error) {
	query := getTxsByTxid
	var queryParams []interface{}
	if len(arg.Ids1) > 0 {
		for _, v := range arg.Ids1 {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids1*/?", strings.Repeat(",?", len(arg.Ids1))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids1*/?", "NULL", 1)
	}
	if len(arg.Ids2) > 0 {
		for _, v := range arg.Ids2 {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids2*/?", strings.Repeat(",?", len(arg.Ids2))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids2*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTxsByTxidRow
	for rows.Next() {
		var i GetTxsByTxidRow
		if err := rows.Scan(&i.Txid, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMarketHour = `-- name: InsertMarketHour :one
INSERT INTO market_hour (
    start_time,
    end_time,
    period,
    round_interval,
    updated_at
) VALUES (?, ?, ?, ?, ?)
RETURNING id, start_time, end_time, period, round_interval, updated_at
`

type InsertMarketHourParams struct {
	StartTime     int64
	EndTime       int64
	Period        int64
	RoundInterval int64
	UpdatedAt     int64
}

func (q *Queries) InsertMarketHour(ctx context.Context, arg InsertMarketHourParams) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, insertMarketHour,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.RoundInterval,
		arg.UpdatedAt,
	)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const markVtxoAsRedeemed = `-- name: MarkVtxoAsRedeemed :exec
UPDATE vtxo SET redeemed = true WHERE txid = ? AND vout = ?
`

type MarkVtxoAsRedeemedParams struct {
	Txid string
	Vout int64
}

func (q *Queries) MarkVtxoAsRedeemed(ctx context.Context, arg MarkVtxoAsRedeemedParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsRedeemed, arg.Txid, arg.Vout)
	return err
}

const markVtxoAsSpent = `-- name: MarkVtxoAsSpent :exec
UPDATE vtxo SET spent = true, spent_by = ? WHERE txid = ? AND vout = ?
`

type MarkVtxoAsSpentParams struct {
	SpentBy string
	Txid    string
	Vout    int64
}

func (q *Queries) MarkVtxoAsSpent(ctx context.Context, arg MarkVtxoAsSpentParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsSpent, arg.SpentBy, arg.Txid, arg.Vout)
	return err
}

const markVtxoAsSwept = `-- name: MarkVtxoAsSwept :exec
UPDATE vtxo SET swept = true WHERE txid = ? AND vout = ?
`

type MarkVtxoAsSweptParams struct {
	Txid string
	Vout int64
}

func (q *Queries) MarkVtxoAsSwept(ctx context.Context, arg MarkVtxoAsSweptParams) error {
	_, err := q.db.ExecContext(ctx, markVtxoAsSwept, arg.Txid, arg.Vout)
	return err
}

const selectAllVtxos = `-- name: SelectAllVtxos :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
`

type SelectAllVtxosRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectAllVtxos(ctx context.Context) ([]SelectAllVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectAllVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllVtxosRow
	for rows.Next() {
		var i SelectAllVtxosRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectLeafVtxosByRoundTxid = `-- name: SelectLeafVtxosByRoundTxid :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE round_tx = ? AND (redeem_tx IS NULL or redeem_tx = '')
`

type SelectLeafVtxosByRoundTxidRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectLeafVtxosByRoundTxid(ctx context.Context, roundTx string) ([]SelectLeafVtxosByRoundTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectLeafVtxosByRoundTxid, roundTx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectLeafVtxosByRoundTxidRow
	for rows.Next() {
		var i SelectLeafVtxosByRoundTxidRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotRedeemedVtxos = `-- name: SelectNotRedeemedVtxos :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE redeemed = false
`

type SelectNotRedeemedVtxosRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectNotRedeemedVtxos(ctx context.Context) ([]SelectNotRedeemedVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotRedeemedVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotRedeemedVtxosRow
	for rows.Next() {
		var i SelectNotRedeemedVtxosRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotRedeemedVtxosWithPubkey = `-- name: SelectNotRedeemedVtxosWithPubkey :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE redeemed = false AND pubkey = ?
`

type SelectNotRedeemedVtxosWithPubkeyRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectNotRedeemedVtxosWithPubkey(ctx context.Context, pubkey string) ([]SelectNotRedeemedVtxosWithPubkeyRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotRedeemedVtxosWithPubkey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotRedeemedVtxosWithPubkeyRow
	for rows.Next() {
		var i SelectNotRedeemedVtxosWithPubkeyRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIds = `-- name: SelectRoundIds :many
SELECT id FROM round
`

func (q *Queries) SelectRoundIds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsInRange = `-- name: SelectRoundIdsInRange :many
SELECT id FROM round WHERE starting_timestamp > ? AND starting_timestamp < ?
`

type SelectRoundIdsInRangeParams struct {
	StartingTimestamp   int64
	StartingTimestamp_2 int64
}

func (q *Queries) SelectRoundIdsInRange(ctx context.Context, arg SelectRoundIdsInRangeParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsInRange, arg.StartingTimestamp, arg.StartingTimestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithRoundId = `-- name: SelectRoundWithRoundId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.txid, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration,
       round_request_vw.id, round_request_vw.round_id,
       round_tx_vw.txid, round_tx_vw.tx, round_tx_vw.round_id, round_tx_vw.type, round_tx_vw.position, round_tx_vw.children,
       request_receiver_vw.request_id, request_receiver_vw.pubkey, request_receiver_vw.onchain_address, request_receiver_vw.amount,
       request_vtxo_vw.txid, request_vtxo_vw.vout, request_vtxo_vw.pubkey, request_vtxo_vw.amount, request_vtxo_vw.round_tx, request_vtxo_vw.spent_by, request_vtxo_vw.spent, request_vtxo_vw.redeemed, request_vtxo_vw.swept, request_vtxo_vw.expire_at, request_vtxo_vw.created_at, request_vtxo_vw.request_id, request_vtxo_vw.redeem_tx
FROM round
         LEFT OUTER JOIN round_request_vw ON round.id=round_request_vw.round_id
         LEFT OUTER JOIN round_tx_vw ON round.id=round_tx_vw.round_id
         LEFT OUTER JOIN request_receiver_vw ON round_request_vw.id=request_receiver_vw.request_id
         LEFT OUTER JOIN request_vtxo_vw ON round_request_vw.id=request_vtxo_vw.request_id
WHERE round.id = ?
`

type SelectRoundWithRoundIdRow struct {
	Round             Round
	RoundRequestVw    RoundRequestVw
	RoundTxVw         RoundTxVw
	RequestReceiverVw RequestReceiverVw
	RequestVtxoVw     RequestVtxoVw
}

func (q *Queries) SelectRoundWithRoundId(ctx context.Context, id string) ([]SelectRoundWithRoundIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithRoundId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithRoundIdRow
	for rows.Next() {
		var i SelectRoundWithRoundIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.Txid,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.RoundRequestVw.ID,
			&i.RoundRequestVw.RoundID,
			&i.RoundTxVw.Txid,
			&i.RoundTxVw.Tx,
			&i.RoundTxVw.RoundID,
			&i.RoundTxVw.Type,
			&i.RoundTxVw.Position,
			&i.RoundTxVw.Children,
			&i.RequestReceiverVw.RequestID,
			&i.RequestReceiverVw.Pubkey,
			&i.RequestReceiverVw.OnchainAddress,
			&i.RequestReceiverVw.Amount,
			&i.RequestVtxoVw.Txid,
			&i.RequestVtxoVw.Vout,
			&i.RequestVtxoVw.Pubkey,
			&i.RequestVtxoVw.Amount,
			&i.RequestVtxoVw.RoundTx,
			&i.RequestVtxoVw.SpentBy,
			&i.RequestVtxoVw.Spent,
			&i.RequestVtxoVw.Redeemed,
			&i.RequestVtxoVw.Swept,
			&i.RequestVtxoVw.ExpireAt,
			&i.RequestVtxoVw.CreatedAt,
			&i.RequestVtxoVw.RequestID,
			&i.RequestVtxoVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithRoundTxId = `-- name: SelectRoundWithRoundTxId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.txid, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration,
       round_request_vw.id, round_request_vw.round_id,
       round_tx_vw.txid, round_tx_vw.tx, round_tx_vw.round_id, round_tx_vw.type, round_tx_vw.position, round_tx_vw.children,
       request_receiver_vw.request_id, request_receiver_vw.pubkey, request_receiver_vw.onchain_address, request_receiver_vw.amount,
       request_vtxo_vw.txid, request_vtxo_vw.vout, request_vtxo_vw.pubkey, request_vtxo_vw.amount, request_vtxo_vw.round_tx, request_vtxo_vw.spent_by, request_vtxo_vw.spent, request_vtxo_vw.redeemed, request_vtxo_vw.swept, request_vtxo_vw.expire_at, request_vtxo_vw.created_at, request_vtxo_vw.request_id, request_vtxo_vw.redeem_tx
FROM round
         LEFT OUTER JOIN round_request_vw ON round.id=round_request_vw.round_id
         LEFT OUTER JOIN round_tx_vw ON round.id=round_tx_vw.round_id
         LEFT OUTER JOIN request_receiver_vw ON round_request_vw.id=request_receiver_vw.request_id
         LEFT OUTER JOIN request_vtxo_vw ON round_request_vw.id=request_vtxo_vw.request_id
WHERE round.txid = ?
`

type SelectRoundWithRoundTxIdRow struct {
	Round             Round
	RoundRequestVw    RoundRequestVw
	RoundTxVw         RoundTxVw
	RequestReceiverVw RequestReceiverVw
	RequestVtxoVw     RequestVtxoVw
}

func (q *Queries) SelectRoundWithRoundTxId(ctx context.Context, txid string) ([]SelectRoundWithRoundTxIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithRoundTxId, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithRoundTxIdRow
	for rows.Next() {
		var i SelectRoundWithRoundTxIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.Txid,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.RoundRequestVw.ID,
			&i.RoundRequestVw.RoundID,
			&i.RoundTxVw.Txid,
			&i.RoundTxVw.Tx,
			&i.RoundTxVw.RoundID,
			&i.RoundTxVw.Type,
			&i.RoundTxVw.Position,
			&i.RoundTxVw.Children,
			&i.RequestReceiverVw.RequestID,
			&i.RequestReceiverVw.Pubkey,
			&i.RequestReceiverVw.OnchainAddress,
			&i.RequestReceiverVw.Amount,
			&i.RequestVtxoVw.Txid,
			&i.RequestVtxoVw.Vout,
			&i.RequestVtxoVw.Pubkey,
			&i.RequestVtxoVw.Amount,
			&i.RequestVtxoVw.RoundTx,
			&i.RequestVtxoVw.SpentBy,
			&i.RequestVtxoVw.Spent,
			&i.RequestVtxoVw.Redeemed,
			&i.RequestVtxoVw.Swept,
			&i.RequestVtxoVw.ExpireAt,
			&i.RequestVtxoVw.CreatedAt,
			&i.RequestVtxoVw.RequestID,
			&i.RequestVtxoVw.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableVtxos = `-- name: SelectSweepableVtxos :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE redeemed = false AND swept = false
`

type SelectSweepableVtxosRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectSweepableVtxos(ctx context.Context) ([]SelectSweepableVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectSweepableVtxosRow
	for rows.Next() {
		var i SelectSweepableVtxosRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweptRoundsConnectorAddress = `-- name: SelectSweptRoundsConnectorAddress :many
SELECT round.connector_address FROM round
WHERE round.swept = true AND round.failed = false AND round.ended = true AND round.connector_address <> ''
`

func (q *Queries) SelectSweptRoundsConnectorAddress(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweptRoundsConnectorAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var connector_address string
		if err := rows.Scan(&connector_address); err != nil {
			return nil, err
		}
		items = append(items, connector_address)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTreeTxsWithRoundTxid = `-- name: SelectTreeTxsWithRoundTxid :many
SELECT tx.txid, tx.tx, tx.round_id, tx.type, tx.position, tx.children FROM round
LEFT OUTER JOIN tx ON round.id=tx.round_id
WHERE round.txid = ? AND tx.type = 'tree'
`

type SelectTreeTxsWithRoundTxidRow struct {
	Txid     sql.NullString
	Tx       sql.NullString
	RoundID  sql.NullString
	Type     sql.NullString
	Position sql.NullInt64
	Children sql.NullString
}

func (q *Queries) SelectTreeTxsWithRoundTxid(ctx context.Context, txid string) ([]SelectTreeTxsWithRoundTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectTreeTxsWithRoundTxid, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectTreeTxsWithRoundTxidRow
	for rows.Next() {
		var i SelectTreeTxsWithRoundTxidRow
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUnsweptRoundsTxid = `-- name: SelectUnsweptRoundsTxid :many
SELECT round.txid FROM round
WHERE round.swept = false AND round.ended = true AND round.failed = false
`

func (q *Queries) SelectUnsweptRoundsTxid(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectUnsweptRoundsTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVirtualTxWithTxId = `-- name: SelectVirtualTxWithTxId :many
SELECT  virtual_tx_checkpoint_tx_vw.txid, virtual_tx_checkpoint_tx_vw.tx, virtual_tx_checkpoint_tx_vw.starting_timestamp, virtual_tx_checkpoint_tx_vw.ending_timestamp, virtual_tx_checkpoint_tx_vw.expiry_timestamp, virtual_tx_checkpoint_tx_vw.fail_reason, virtual_tx_checkpoint_tx_vw.stage_code, virtual_tx_checkpoint_tx_vw.checkpoint_txid, virtual_tx_checkpoint_tx_vw.checkpoint_tx, virtual_tx_checkpoint_tx_vw.commitment_txid, virtual_tx_checkpoint_tx_vw.is_root_commitment_tx, virtual_tx_checkpoint_tx_vw.virtual_txid
FROM virtual_tx_checkpoint_tx_vw WHERE txid = ?1
`

type SelectVirtualTxWithTxIdRow struct {
	VirtualTxCheckpointTxVw VirtualTxCheckpointTxVw
}

func (q *Queries) SelectVirtualTxWithTxId(ctx context.Context, txid string) ([]SelectVirtualTxWithTxIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVirtualTxWithTxId, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVirtualTxWithTxIdRow
	for rows.Next() {
		var i SelectVirtualTxWithTxIdRow
		if err := rows.Scan(
			&i.VirtualTxCheckpointTxVw.Txid,
			&i.VirtualTxCheckpointTxVw.Tx,
			&i.VirtualTxCheckpointTxVw.StartingTimestamp,
			&i.VirtualTxCheckpointTxVw.EndingTimestamp,
			&i.VirtualTxCheckpointTxVw.ExpiryTimestamp,
			&i.VirtualTxCheckpointTxVw.FailReason,
			&i.VirtualTxCheckpointTxVw.StageCode,
			&i.VirtualTxCheckpointTxVw.CheckpointTxid,
			&i.VirtualTxCheckpointTxVw.CheckpointTx,
			&i.VirtualTxCheckpointTxVw.CommitmentTxid,
			&i.VirtualTxCheckpointTxVw.IsRootCommitmentTx,
			&i.VirtualTxCheckpointTxVw.VirtualTxid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxoByOutpoint = `-- name: SelectVtxoByOutpoint :one
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE txid = ? AND vout = ?
`

type SelectVtxoByOutpointParams struct {
	Txid string
	Vout int64
}

type SelectVtxoByOutpointRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectVtxoByOutpoint(ctx context.Context, arg SelectVtxoByOutpointParams) (SelectVtxoByOutpointRow, error) {
	row := q.db.QueryRowContext(ctx, selectVtxoByOutpoint, arg.Txid, arg.Vout)
	var i SelectVtxoByOutpointRow
	err := row.Scan(
		&i.Vtxo.Txid,
		&i.Vtxo.Vout,
		&i.Vtxo.Pubkey,
		&i.Vtxo.Amount,
		&i.Vtxo.RoundTx,
		&i.Vtxo.SpentBy,
		&i.Vtxo.Spent,
		&i.Vtxo.Redeemed,
		&i.Vtxo.Swept,
		&i.Vtxo.ExpireAt,
		&i.Vtxo.CreatedAt,
		&i.Vtxo.RequestID,
		&i.Vtxo.RedeemTx,
	)
	return i, err
}

const selectVtxosByRoundTxid = `-- name: SelectVtxosByRoundTxid :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo
WHERE round_tx = ?
`

type SelectVtxosByRoundTxidRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectVtxosByRoundTxid(ctx context.Context, roundTx string) ([]SelectVtxosByRoundTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosByRoundTxid, roundTx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosByRoundTxidRow
	for rows.Next() {
		var i SelectVtxosByRoundTxidRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosWithPubkey = `-- name: SelectVtxosWithPubkey :many
SELECT vtxo.txid, vtxo.vout, vtxo.pubkey, vtxo.amount, vtxo.round_tx, vtxo.spent_by, vtxo.spent, vtxo.redeemed, vtxo.swept, vtxo.expire_at, vtxo.created_at, vtxo.request_id, vtxo.redeem_tx FROM vtxo WHERE pubkey = ?
`

type SelectVtxosWithPubkeyRow struct {
	Vtxo Vtxo
}

func (q *Queries) SelectVtxosWithPubkey(ctx context.Context, pubkey string) ([]SelectVtxosWithPubkeyRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosWithPubkey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosWithPubkeyRow
	for rows.Next() {
		var i SelectVtxosWithPubkeyRow
		if err := rows.Scan(
			&i.Vtxo.Txid,
			&i.Vtxo.Vout,
			&i.Vtxo.Pubkey,
			&i.Vtxo.Amount,
			&i.Vtxo.RoundTx,
			&i.Vtxo.SpentBy,
			&i.Vtxo.Spent,
			&i.Vtxo.Redeemed,
			&i.Vtxo.Swept,
			&i.Vtxo.ExpireAt,
			&i.Vtxo.CreatedAt,
			&i.Vtxo.RequestID,
			&i.Vtxo.RedeemTx,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMarketHour = `-- name: UpdateMarketHour :one
UPDATE market_hour
SET start_time = ?,
    end_time = ?,
    period = ?,
    round_interval = ?,
    updated_at = ?
WHERE id = ?
RETURNING id, start_time, end_time, period, round_interval, updated_at
`

type UpdateMarketHourParams struct {
	StartTime     int64
	EndTime       int64
	Period        int64
	RoundInterval int64
	UpdatedAt     int64
	ID            int64
}

func (q *Queries) UpdateMarketHour(ctx context.Context, arg UpdateMarketHourParams) (MarketHour, error) {
	row := q.db.QueryRowContext(ctx, updateMarketHour,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.RoundInterval,
		arg.UpdatedAt,
		arg.ID,
	)
	var i MarketHour
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.RoundInterval,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVtxoExpireAt = `-- name: UpdateVtxoExpireAt :exec
UPDATE vtxo SET expire_at = ? WHERE txid = ? AND vout = ?
`

type UpdateVtxoExpireAtParams struct {
	ExpireAt int64
	Txid     string
	Vout     int64
}

func (q *Queries) UpdateVtxoExpireAt(ctx context.Context, arg UpdateVtxoExpireAtParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoExpireAt, arg.ExpireAt, arg.Txid, arg.Vout)
	return err
}

const updateVtxoRequestId = `-- name: UpdateVtxoRequestId :exec
UPDATE vtxo SET request_id = ? WHERE txid = ? AND vout = ?
`

type UpdateVtxoRequestIdParams struct {
	RequestID sql.NullString
	Txid      string
	Vout      int64
}

func (q *Queries) UpdateVtxoRequestId(ctx context.Context, arg UpdateVtxoRequestIdParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoRequestId, arg.RequestID, arg.Txid, arg.Vout)
	return err
}

const upsertCheckpointTx = `-- name: UpsertCheckpointTx :exec
INSERT INTO checkpoint_tx (
    txid, tx, commitment_txid, is_root_commitment_tx, virtual_txid
) VALUES (?1, ?2, ?3, ?4, ?5)
    ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    commitment_txid = EXCLUDED.commitment_txid,
    is_root_commitment_tx = EXCLUDED.is_root_commitment_tx,
    virtual_txid = EXCLUDED.virtual_txid
`

type UpsertCheckpointTxParams struct {
	Txid               string
	Tx                 string
	CommitmentTxid     string
	IsRootCommitmentTx bool
	VirtualTxid        string
}

func (q *Queries) UpsertCheckpointTx(ctx context.Context, arg UpsertCheckpointTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertCheckpointTx,
		arg.Txid,
		arg.Tx,
		arg.CommitmentTxid,
		arg.IsRootCommitmentTx,
		arg.VirtualTxid,
	)
	return err
}

const upsertReceiver = `-- name: UpsertReceiver :exec
INSERT INTO receiver (request_id, pubkey, onchain_address, amount) VALUES (?, ?, ?, ?)
ON CONFLICT(request_id, pubkey, onchain_address) DO UPDATE SET
    amount = EXCLUDED.amount,
    pubkey = EXCLUDED.pubkey,
    onchain_address = EXCLUDED.onchain_address
`

type UpsertReceiverParams struct {
	RequestID      string
	Pubkey         sql.NullString
	OnchainAddress sql.NullString
	Amount         int64
}

func (q *Queries) UpsertReceiver(ctx context.Context, arg UpsertReceiverParams) error {
	_, err := q.db.ExecContext(ctx, upsertReceiver,
		arg.RequestID,
		arg.Pubkey,
		arg.OnchainAddress,
		arg.Amount,
	)
	return err
}

const upsertRound = `-- name: UpsertRound :exec
INSERT INTO round (
    id,
    starting_timestamp,
    ending_timestamp,
    ended, failed,
    stage_code,
    txid,
    connector_address,
    version,
    swept,
    vtxo_tree_expiration
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    ended = EXCLUDED.ended,
    failed = EXCLUDED.failed,
    stage_code = EXCLUDED.stage_code,
    txid = EXCLUDED.txid,
    connector_address = EXCLUDED.connector_address,
    version = EXCLUDED.version,
    swept = EXCLUDED.swept,
    vtxo_tree_expiration = EXCLUDED.vtxo_tree_expiration
`

type UpsertRoundParams struct {
	ID                 string
	StartingTimestamp  int64
	EndingTimestamp    int64
	Ended              bool
	Failed             bool
	StageCode          int64
	Txid               string
	ConnectorAddress   string
	Version            int64
	Swept              bool
	VtxoTreeExpiration int64
}

func (q *Queries) UpsertRound(ctx context.Context, arg UpsertRoundParams) error {
	_, err := q.db.ExecContext(ctx, upsertRound,
		arg.ID,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.Ended,
		arg.Failed,
		arg.StageCode,
		arg.Txid,
		arg.ConnectorAddress,
		arg.Version,
		arg.Swept,
		arg.VtxoTreeExpiration,
	)
	return err
}

const upsertTransaction = `-- name: UpsertTransaction :exec
INSERT INTO tx (
    tx, round_id, type, position, txid, children
) VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    round_id = EXCLUDED.round_id,
    type = EXCLUDED.type,
    position = EXCLUDED.position,
    txid = EXCLUDED.txid,
    children = EXCLUDED.children
`

type UpsertTransactionParams struct {
	Tx       string
	RoundID  string
	Type     string
	Position int64
	Txid     string
	Children sql.NullString
}

func (q *Queries) UpsertTransaction(ctx context.Context, arg UpsertTransactionParams) error {
	_, err := q.db.ExecContext(ctx, upsertTransaction,
		arg.Tx,
		arg.RoundID,
		arg.Type,
		arg.Position,
		arg.Txid,
		arg.Children,
	)
	return err
}

const upsertTxRequest = `-- name: UpsertTxRequest :exec
INSERT INTO tx_request (id, round_id) VALUES (?, ?)
ON CONFLICT(id) DO UPDATE SET round_id = EXCLUDED.round_id
`

type UpsertTxRequestParams struct {
	ID      string
	RoundID string
}

func (q *Queries) UpsertTxRequest(ctx context.Context, arg UpsertTxRequestParams) error {
	_, err := q.db.ExecContext(ctx, upsertTxRequest, arg.ID, arg.RoundID)
	return err
}

const upsertVirtualTx = `-- name: UpsertVirtualTx :exec
INSERT INTO virtual_tx (
    txid, tx, starting_timestamp, ending_timestamp, expiry_timestamp, fail_reason, stage_code
) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)
    ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    expiry_timestamp = EXCLUDED.expiry_timestamp,
    fail_reason = EXCLUDED.fail_reason,
    stage_code = EXCLUDED.stage_code
`

type UpsertVirtualTxParams struct {
	Txid              string
	Tx                string
	StartingTimestamp int64
	EndingTimestamp   int64
	ExpiryTimestamp   int64
	FailReason        sql.NullString
	StageCode         int64
}

func (q *Queries) UpsertVirtualTx(ctx context.Context, arg UpsertVirtualTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertVirtualTx,
		arg.Txid,
		arg.Tx,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.ExpiryTimestamp,
		arg.FailReason,
		arg.StageCode,
	)
	return err
}

const upsertVtxo = `-- name: UpsertVtxo :exec
INSERT INTO vtxo (txid, vout, pubkey, amount, round_tx, spent_by, spent, redeemed, swept, expire_at, created_at, redeem_tx)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT(txid, vout) DO UPDATE SET
    pubkey = EXCLUDED.pubkey,
    amount = EXCLUDED.amount,
    round_tx = EXCLUDED.round_tx,
    spent_by = EXCLUDED.spent_by,
    spent = EXCLUDED.spent,
    redeemed = EXCLUDED.redeemed,
    swept = EXCLUDED.swept,
    expire_at = EXCLUDED.expire_at,
    created_at = EXCLUDED.created_at,
    redeem_tx = EXCLUDED.redeem_tx
`

type UpsertVtxoParams struct {
	Txid      string
	Vout      int64
	Pubkey    string
	Amount    int64
	RoundTx   string
	SpentBy   string
	Spent     bool
	Redeemed  bool
	Swept     bool
	ExpireAt  int64
	CreatedAt int64
	RedeemTx  sql.NullString
}

func (q *Queries) UpsertVtxo(ctx context.Context, arg UpsertVtxoParams) error {
	_, err := q.db.ExecContext(ctx, upsertVtxo,
		arg.Txid,
		arg.Vout,
		arg.Pubkey,
		arg.Amount,
		arg.RoundTx,
		arg.SpentBy,
		arg.Spent,
		arg.Redeemed,
		arg.Swept,
		arg.ExpireAt,
		arg.CreatedAt,
		arg.RedeemTx,
	)
	return err
}
